{
  "api/RealtimeCSG.Components.CSGModel.html": {
    "href": "api/RealtimeCSG.Components.CSGModel.html",
    "title": "Class CSGModel | RealtimeCSG",
    "keywords": "Class CSGModel Holds a CSG tree and generates meshes for that CSG tree Inheritance Object CSGNode CSGModel Syntax public sealed class CSGModel : CSGNode Remarks The CSG tree that defines a model is defined by its child UnityEngine.GameObject s. Fields Version Declaration public float Version Field Value Single The version number of this instance of a CSGModel"
  },
  "api/RealtimeCSG.Components.CSGNode.html": {
    "href": "api/RealtimeCSG.Components.CSGNode.html",
    "title": "Class CSGNode | RealtimeCSG",
    "keywords": "Class CSGNode Parent class of CSGBrush / CSGOperation / CSGModel Inheritance Object CSGNode CSGBrush CSGModel CSGOperation Syntax public abstract class CSGNode : MonoBehaviour"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "The Realtime CSG API | RealtimeCSG",
    "keywords": "The Realtime CSG API Namespace layers Description RealtimeCSG.Foundation Low level API that makes it possible to generate geometry using CSG purely from code RealtimeCSG.Legacy Legacy low level code that is only here as a bridge between old code and new code. This will (eventually) be removed when no longer necessary. RealtimeCSG.Components Generic MonoBehaviour components that use RealtimeCSG.Foundation (and for the time being RealtimeCSG.Legacy) to be able to build CSG trees and BrushMeshes from within the Editor RealtimeCSG.Parametric (Future) MonoBehaviour components that parametricly build whole parts of a CSG tree based on inputs. This can be as simple as a cubes or cylinders, to stairs and extruded geometry from 2D shapes This page is a work in progress . It will be updated within the next weeks."
  },
  "documentation/meshQuery.html": {
    "href": "documentation/meshQuery.html",
    "title": "Mesh Queries | RealtimeCSG",
    "keywords": "Mesh Queries This page is a work in progress . It will be updated within the next weeks. For the time being, here's an example instead: // The mesh queries define how meshes are generated using // the BrushMesh surface layer information MeshQuery[] meshQueries = { new MeshQuery( // Create meshes, one for each surface layer (layerParameter1) // with a different type of 'Material'. // Does not select surface layers with a layerParameter1 of 0. // Ignores all other layer parameters. parameterIndex: LayerParameterIndex.RenderMaterial, // Uses all vertex channels. vertexChannels: VertexChannelFlags.All, // Find surface layers with 'Renderable', 'CastShadows' // and/or 'ReceiveShadows' flags. mask: LayerUsageFlags.RenderReceiveCastShadows, // Only select the ones that have them all set. query: LayerUsageFlags.RenderReceiveCastShadows ), new MeshQuery( // Create meshes, one for each surface layer (layerParameter1) // with a different type of 'Material'. // Does not select surface layers with a layerParameter1 of 0. // Ignores all other layer parameters. parameterIndex: LayerParameterIndex.RenderMaterial, // Uses all vertex channels. vertexChannels: VertexChannelFlags.All, // Find surface layers with 'Renderable', 'CastShadows' // and/or 'ReceiveShadows' flags. mask: LayerUsageFlags.RenderReceiveCastShadows, // Only select the ones that have both 'Renderable' and // 'Cast Shadows' set. Will reject any surface layer that // has the 'ReceiveShadows' flag set. query: LayerUsageFlags.RenderCastShadows ), new MeshQuery( // Create meshes, one for each surface layer (layerParameter1) // with a different type of 'Material'. // Does not select surface layers with a layerParameter1 of 0. // Ignores all other layer parameters. parameterIndex: LayerParameterIndex.RenderMaterial, // Uses all vertex channels. vertexChannels: VertexChannelFlags.All, // Find surface layers with 'Renderable', 'CastShadows' // and/or 'ReceiveShadows' flags. mask: LayerUsageFlags.RenderReceiveCastShadows, // Only select the ones that have both 'Renderable' and // 'Receive Shadows' set. Will reject any surface layer // that has the 'CastShadows' flag set. query: LayerUsageFlags.RenderReceiveShadows ), Note: See \" Create Unity Mesh \" on how to create a Unity Mesh using this MeshQuery"
  },
  "documentation/createUnityMesh.html": {
    "href": "documentation/createUnityMesh.html",
    "title": "Creating Unity Meshes | RealtimeCSG",
    "keywords": "Creating Unity Meshes This page is a work in progress . It will be updated within the next weeks. For the time being, here's an example instead: // The mesh queries define how meshes are generated using the BrushMesh surface layer information MeshQuery[] meshQueries = GetMeshQueries(); // Create a tree // Note: this can be cached and updated separately. CSGTree tree = CreateTree(); // At this point, when you have a tree that you update frequently, you can also potentially check if it's Dirty or not. // If it is, it means it has been modified since the last time tree.GetMeshDescriptions has been called. // Find all the potential meshes that could be generated with our queries. // There is no guarantee that these meshes will exist. It might also be split into multiple meshes when it's too large GeneratedMeshDescription[] meshDescriptions = tree.GetMeshDescriptions(meshQueries, VertexChannelFlags.All); if (meshDescriptions != null) { // Iterate through all the meshes that we've found foreach (var meshDescription in meshDescriptions) { // At this point, it's possible to check the Hash values stored in meshDescription, // to check if this particular type of mesh has already been generated before (perhaps in a previous iteration) // You could then potentially early out and avoid retrieving the generated mesh and converting it into a new UnityEngine.Mesh. // Actually generate the mesh on the native side, potentially generate smooth normals etc. and retrieve the mesh. GeneratedMeshContents contents = tree.GetGeneratedMesh(meshDescription); // Note: It's possible to re-use this UnityEngine.Mesh UnityEngine.Mesh unityMesh = new UnityEngine.Mesh(); // Copy the generated mesh to the UnityEngine.Mesh contents.CopyTo(unityMesh); // ... assign it to a MeshRenderer/MeshCollider etc. } } Note: See \" CSG Trees \" on how to create the CSG tree in this example Note: See \" Mesh Queries \" on how to create the Mesh Queries in this example"
  },
  "documentation/keyboardLayout.html": {
    "href": "documentation/keyboardLayout.html",
    "title": "Keyboard Layout | RealtimeCSG",
    "keywords": "Keyboard Layout Key Description All edit modes Control-F2 Undock tool window Control-F3 Enable/Disable realtime-CSG H Hide all selected objects Control-H Hide all unselected objects Shift-H Toggle visibility all selected objects U Unhide all selected objects Escape Cancel / Deselect Enter/Return Commit Control-End Cycle edit mode forward Control-Home Cycle edit mode backward ? Make selected operation pass-through = or + Make selected brush/operation additive - Make selected brush/operation subtractive / Make selected brush/operation intersecting N Toggle Free-draw generation edit mode C Toggle Cylinder-draw generation edit mode B Toggle Box-draw generation edit mode [ Half grid side ] Double grid size G Toggle grid shift Shift-T Toggle snapping ALT-F1 Object edit mode ALT-F2 Generate edit mode ALT-F3 Mesh edit mode ALT-F4 Clip edit mode ALT-F5 Surface edit mode Generator edit mode Delete Delete selected free-draw shape points Enter Create brush from current shape Esc Cancel shape Mesh edit mode M Merge vertices of selected edge Control-End Snap selection to grid hold D Drag a clone of your selection hold Z Move selection up hold Shift Move surface in it's facing direction ALT + click Create free-draw shape from surface (click center point) to extrude it Delete Delete selected vertices Control-Shift-X Flip selected brushes over X axis Control-Shift-Y Flip selected brushes over Y axis Control-Shift-Z Flip selected brushes over Z axis Object edit mode hold D Drag a clone of your selection hold Z Change move direction to up/down Control-Shift-X Flip selected brushes over X axis Control-Shift-Y Flip selected brushes over Y axis Control-Shift-Z Flip selected brushes over Z axis Ctrl-Left-Arrow Move selection to the left (-X) with a grid sized step Ctrl-Right-Arrow Move selection to the right (+X) with a grid sized step Ctrl-Down-Arrow Move selection to the back (-Z) with a grid sized step Ctrl-Up-Arrow Move selection to the forward (+Z) with a grid sized step Ctrl-Page-Down Move selection to the down (-Y) with a grid sized step Ctrl-Page-Up Move selection to the up (+Y) with a grid sized step Control-. Rotate selection to the left (Y) with a rotation snap sized step Control-, Rotate selection to the right (Y) with a rotation snap sized step Surface edit mode G Copy previous material to surface you click on Hold G Smear material over surfaces you drag over"
  },
  "documentation/index.html": {
    "href": "documentation/index.html",
    "title": "What is CSG? | RealtimeCSG",
    "keywords": "What is CSG? CSG stands for Constructive Solid Geometry and is a technique to build models by combining and removing simple shapes called brushes , using boolean operations . The advantage of using CSG for level design is that it's very easy to both define and modify spaces within a game, to start simple and refine later on. Since level design is a lot about iteration and not so much about generating geometry, CSG is a more appropriate technology to quickly prototype and form the basis of your levels. Brushes can easily be moved around, it takes seconds to move windows, doorways and whole sections of a level around and you don't need to worry about vertices & triangles or the gaps between them. For this reason CSG has traditionally been used for level design by many companies throughout the history of the game industry. What are brushes? Brushes are simple shapes that act as building blocks to build more complicated shapes using boolean operations . convex non-convex Brushes are restricted to be convex, this means that you can never have surfaces that create an inwards corner. So for instance spheres, cubes, pyramids and cylinders are all fine. But an L shape isn’t convex. multiple convex brushes Fortunately it’s possible to build any shape out of multiple convex shapes. An L shape can be created from 2 box shapes for instance. Real Time-CSG has tools to free-draw shapes that will generate all the brushes under the hood for you. For more information about creating brushes, see the generate edit mode section. What are boolean operations? Boolean operations define how brushes interact with each other. The following boolean operations are supported by real-time CSG. Addition of cube and cylinder Intersection of cube and cylinder Subtraction of cube by cylinder Sometimes you’ll also see “ Passthrough” which is a special mode that doesn’t actually perform a CSG operation, but helps group things together when, for instance, drag & dropping. For more information about passthrough mode see the passthrough section of drag & drop . To make more interesting shapes you can perform boolean operations on the results of other boolean operations. To the left you can see a shape defined by subtracting another shape, which itself is defined as a cube subtracted by a cylinder. Since all the shapes and operations are non-destructive and real-time, you can move, rotate, scale or modify all the basic shapes and their operations and the final mesh will change accordingly. The picture on the left you can see how the hierarchy looks to get the previously shown picture. All CSG operations are applied from top to bottom. The large cube is an additive brush from which all items below are removed. The second item is a subtraction operation which combines the items inside it, and subtract that from the Large cube which is above it in the hierarchy. The small cube is an additive brush from which the last item, the cylinder, is subtracted. Since the “subtraction operation” is set to subtraction, the shape defined by subtracting the cylinder from the cube is subtracting from everything above it in the hierarchy. What are models? Models are objects that hold all the meshes that are created from all the brushes and operations that are contained by the model. At runtime (in play-mode or in your build) all the operations and brushes are removed and replaced by these meshes. This means that anything you can do with a regular Unity mesh at runtime, you can do with a model as well. regular world inverted world An important setting you can set on models is the “Inverted world” setting, this will make the model consider the world solid by default, and you’ll need to remove from it to create geometry. This is useful for when the geometry you want to make doesn’t have any outer walls and you don’t want to be bothered with manually discarding (removing) these unused surfaces. For more information about models, see the model settings and tools section, for more information about discarding surfaces, see the surface edit mode. The scene view Here is an overview of all the elements that you’ll see in your view when Real Time-CSG is enabled. Note that when Real Time-CSG is disabled (you can toggle this by pressing control-F3) all the extra elements will not be shown and you will just see the default unity scene view. Also note that if you click on the x buttons of the \"edit modes\" and \"tool\" windows, then you convert the in scene windows into a dockable window . Transform Tools. See edit modes for more information. Transform Gizmo Toggles. See the grid for more information. Edit modes. See edit modes for more information. The grid. See the grid for more information. Edit mode helper window. See edit modes for more information. Turn grid rendering on/off. See the grid for more information.. Lock movement along X, Y and/or Z axis. See the grid for more information.. Turn snapping on or off. See the grid for more information. The grid snapping step size for movement. See the grid for more information. Click to cycle between the units to show the snapping step size in (meters, centimeters, feet, inches). See the grid for more information. Double (+) or half (-) the grid snapping step size. See the grid for more information. The snapping size for rotation. (used while rotating). Double (+) or half (-) the rotation snapping. The scale snapping size. (used while scaling). Multiply the scale snapping size by 10 (+) or divide by 10 (-). Toggle wireframe mode for this view. See wireframe mode for more information. Toggle which helper surfaces to show. See helper surfaces for more information. Force rebuild all the CSG models. Dockable window Both the in scene “edit modes” and “tool window” have an x button in the top right corner. When clicked, both windows will change in a combined dockable window: You can dock this window just like, for instance, an inspector window. If you close that window it’ll revert back to the in scene windows above. The grid show/hide grid enable/disable snapping The grid lines show where, if snapping is enabled, the brushes are snapped against. The orientation of the grid shows in what direction the axi are turned. unity set to global mode unity set to local mode If the transform gizmo toggles (see the scene view ) are set to global the grid will always be orientated with an unrotated XZ plane. If it’s set to local, however, then the grid shows how the current selected object is rotated. grid snapping set to 1 m grid snapping set to 0.25 m The grid snapping step size sets the distance between the lines which you snap your brushes against if snapping is enabled. manually set the grid size double (+) or half (-) the grid size You can manually set the grid size in the number section, or click on the +/- buttons to double or half the grid size. set the same grid size for X, Y and Z set a different grid size for X, Y and Z If you click on position then you can toggle between the grid size being set for all axis uniformly or for all axis individually. unit set to meters unit set to centimeters unit set to milimeters :-: :-: :-: :-: :-: :-: unit set to feet unit set to inches If you click on the little symbol behind the position value you can cycle between all the different distance units and the values will be shown in those values. Note that the default internal unit is meters. X axis not locked X axis locked Individual axis can also be locked which makes it impossible to use those axi, which is useful when you want to avoid accidentally moving in a particular direction. Wireframe mode wireframe mode toggle effects button If you toggle the “wireframe mode button” in the toolbar (see the scene view for more information) your sceneview will show your scene but in a special wireframe mode with cleaner lines than the regular unity wireframe mode. You will probably also want to turn off the environment map by clicking on the “effects button”. wireframe mode off, environment map on wireframe mode off, environment map off wireframe mode on, environment map off This makes it easier to see things when things overlap each other. By clicking multiple times on the same location you can cycle between all the objects that overlap each other. Note: Setting this mode sets a special shader and attaches it to the sceneview, unfortunately Unity stores this connection computer-wide. This means that if you open another project that doesn’t have Realtime-CSG it’ll try to use a shader for that view, that doesn’t exist in that project. You can fix this by changing the layout in the top right corner. Helper surfaces Real Time-CSG can show several helper surfaces that help visualize certain surface properties for surfaces that are not actually visible at runtime The following helper surfaces can be shown: description Discarded surfaces These are surfaces that are marked as ‘discarded’ and will not be rendered or be part of the collision mesh. See the surface edit mode for more information about how to flag a surface as being flagged as discarded. Shadow only surfaces These are surfaces (or entire models) that are flagged as “Shadow Only”. These surfaces are only visible to the shadow rendering code. This allows you to see these surfaces. See the surface edit mode for more information about how to flag a surface as being flagged as “Shadow Only”. See model settings and tools for more information on how to flag an entire model as being “Shadow Only”. Invisible surfaces This can visualize all surfaces that are removed by the CSG algorithm. This is useful to, for instance, see a subtractive brush that is not touching any other geometry. A subtractive brush removes geometry and subtracting from nothing results in and shows nothing at runtime. Showing the invisible surfaces allows you to see the subtractive brush. Collider surfaces You can set your model to be a collider only mesh. This surface mode lets you see those meshes since they are not visible at runtime. See model settings and tools for more information. Trigger surfaces You can set your model to be a trigger mesh. This surface mode lets you see those meshes since they are not visible at runtime. See model settings and tools for more information. Selection and placement It’s worth mentioning that Real Time-CSG has some non standard behaviour that might not be obvious at first sight. Deep clicking If you click several times on the same spot, you will cycle between all brushes that beneath the cursor at that point. This makes it easier to select brushes that you might see in wireframe mode, yet is blocked by one or more other brushes. Marquee selection object mode marquee selection Mesh mode marquee selection In object edit mode you can select multiple brushes by clicking outside of your selection and dragging a rectangle that selects all the brushes that are inside it. In mesh edit mode, however, this will select vertices, edges and polygons instead. “Handle as one object” Every CSG operation has a toggle named “Handle as one object”, when enabled this will cause the entire contents of this operation to be handled as if it’s one object. This means that if you click on any brush contained in the operation, all the brushes within the operation will be selected. Drag & drop Drag & dropping Materials onto brushes You can drag any material onto any brush surface by simply dragging the material onto the surface of the brush. If you hold shift while drag & dropping then the material will be applied to all surfaces of all the brushes of the current selection. Drag & dropping Brushes/Operation Prefabs into the scene By default dragging will snap to the grid if snapping is enabled, but by holding control you can reverse this behaviour. This means if the grid is enabled, holding control will disable it while dragging. If the grid is disabled, however, holding control will enable the snapping instead. You can drag & drop onto both MeshRenderers (that have MeshColliders) or onto CSG generated geometry. The moment you’ve turned your CSG operation or CSG brush into a prefab, the following options will be available to you: Instantiation This option allows you to determine if the prefab should be a reference (default unity behaviour) or a copy. The difference is that a copy will not be connected to the original prefab. This is useful for when you want to be able to quickly drag & drop some base shapes into your scene, perhaps as a starting point, but do not want them to be updated when the prefab might change. Placement This option allows you to define how the prefab should be placed into the scene. Default is used to place objects in the same way as unity. Align to surface will place and rotate the prefab to align with the surface under the mouse cursor. Align Surface up will place and rotate the prefab to align with the surface under the mouse cursor but it’s up direction will always be up. This is useful to place things that in the real world always point upwards. Front Since it’s impossible to determine what was considered the front when creating the original prefab, you can specify here the original orientation of the prefab. The names match the names seen in the drop-down in the top right corner. Drag & dropping Meshes into the scene When you drag & drop a mesh, which is not a CSG model, into the scene then it’ll snap to the grid as long as real time-CSG is enabled. It’ll also snap against anything the surfaces behind the cursors just like a regular CSG model would, but unfortunately, due to Unity limitations, there is no way to set up the surface alignment like with brushes. Snapping your meshes to another mesh only works the other mesh has a collider. Passthrough mode Suppose you want to first remove part of a wall using a subtractive brush, and then create the window frame using additive brushes. Without “passthrough mode” you could make an operation be only additive or subtractive, but not both. Which is problematic since you can only set the drag & drop settings on a brush or an operation. Fortunately passthrough mode lets you group multiple brushes (and sub-operations) inside an operation, and let the CSG algorithm ignore the operation itself. Dragging in the scene By holding shift while dragging an operation or brush in the scene, you can move the selected items over the surface beneath the mouse cursor in the same manner as you would during drag & drop. You can set the same options as for the prefab on your operations & brushes. Edit modes Real Time-CSG has several different modes that focus on specific aspects of modeling with brushes. Each edit mode has it’s own helper window that will provide you with context specific information and functionality. This context specific information can depend on the current transform tool (see the scene view for more information) You can choose to have this edit window in the scene view, or as a dockable window . You can switch to the dockable window by pressing the x button of the helper window, or the x button on the edit mode window. Object edit mode When the Object edit mode is activated, each Transform Tool (see the scene view ) has different behavior. Each transform tool will show a different tool window, unless there is no selection. All tool windows will show all the boolean operations (see boolean operations ) that you can set your operations or brushes to. Only operations have the “ Pass through ” option. Another thing to realize is that all movements, rotations and scaling are rotated along with the grid, and this depends on the “ Transform Gizmo Toggles ” global/local settings. (see the grid for more information) When the move tool is selected: You will see the following tool window: Which allows you to manually move an object with the given offset and pressing the “Move” button. If you press “Clone + Move” instead you will move a copy of the original instead. When you move the object using the move handle in scene and then press D you will move a clone of the object you’re moving instead of the original. When the rotate tool is selected: You will see the following tool window: The pivot is the point around you rotate all the selected objects. If the pivot mode of “Transform Gizmo Toggles” (see the scene view) is set to “center” then the pivot will always be set to the center of your selection. You will see a pivot gizmo in the scene that shows you the position of the pivot. If the pivot mode is set to “pivot” you can move it around in the scene.| You can manually set the pivot in the bottom of the tool window. The “Recenter pivot” button will set the current pivot to the center of the selected objects. If you click the Rotate button you will manually rotate the selected objects around the pivot by the given offset rotation by the X / Y / Z rotation values in the Offset part of the tool window. When the scale tool , Or the rect tool is selected: You will see the following tool window: The tool window will only show the boolean operations mentioned in the beginning of this section. In the scene view you will see points on the bounds of your selection which you can drag to scale the selection within your bounds. Only the scale tool will show the scale gizmo at the center of the bounds. Generate edit mode Currently the following brush generators are supported by Real Time-CSG. All generators only finalize their creation when you press enter (commit). You can cancel the creation of your brushes by pressing escape (cancel). Each generator has a tool window that also holds the default material to use for the brushes that are generated, which you can change into any material. Finally, there are the CSG operations that the generated brushes will use that you can set in the tool window. Extruded brushes The following brush generators basically allow you to create a 2D shape on any surface, and then extrude that shape into a 3D brush. If you extrude the shape inwards into another brush, it’ll automatically become a subtractive brush, if you extrude outwards away from the surface you’re extruding from, then it becomes an additive brush. The tool will use the default height when you press enter before you start extruding. The default height will automatically be set to the height of the last extruded brush, or you can set it manually in the tool window. Free-draw This generator allows you to create a generic shape that will automatically be split into multiple convex pieces if necessary. Extruding this shape will then create an operation containing multiple brushes. You can do this by clicking on the surface you want to build a shape on, creating the 2D polygon as you go along. At least 3 points are needed for this polygon to be valid. This 2D polygon can also not self-intersect, although this restriction will probably be removed in the future. When a polygon is not valid, it’ll turn red. Once your shape is created, you can then still move the points around. If you hover over the polygon and drag it, you can extrude it. If you double click on your points or edges, you can turn them into curves. By clicking multiple times you cycle through all the curve/edge modes. An edge can be straight (the default), a mirrored or a broken curve. A mirrored curve means that the curve is continuous on both sides of the edge point, a broken curve means that the edges on both sides of the point can go in different directions. This can mean that on one side of a point, the edge can be straight, but on the other side it’s a curve. If you select an edge, you can then split this edge into two by clicking on the “insert point” button in the tool window for this generator. You can also set the number of times the curve is split into separate pieces in the “Split” text field. The height text field, unsurprisingly, allows you how far the shape is extruded. In the mesh edit mode you can hold shift while dragging on a surface, and it’ll automatically turn into a Free-draw shape that you can then extrude. This allows you to easily extrude surfaces. Just as with regular free-draw shapes you can then still modify the points before you commit them by pressing enter. See mesh edit mode for more information Box The box is a simpler primitive than the free-draw generator, which allows you to quickly create a 2D rectangle which you can then extrude. In its tool window you can manually set the width, length and height of the box. Cylinder The cylinder allows you to create a circle on any surface, and like the free-draw and box generator, extrude it. You create the circle by first giving the center point and then dragging out the second point with the distance between them being the radius of the circle. The tool window allows you to set the “height”, “radius” or the number of “sides” the cylinder will have. Note that setting the number of sides to 3 allows you to create a triangle shaped shape instead. start mid side set start mid side not set angle set to 6 degrees The sides of the circle start at the second point, unless the “Start mid side” is toggled in which case the second point is in the middle of one of the sides instead. The “angle” offset is used to manually rotate the cylinder by the given offset. smooth shading not set smooth shading set The “Smooth shading” toggle allows you to make the sides of the cylinder use normal smoothing, or to give them a faceted look. radial caps not set radial caps set The “Radial caps“ toggle will allow you to determine if the caps of the cylinder will be single polygons or radial caps. The later will look like a fan spreading around the center point. Finally, “Fit shape” is there so when the cylinder has has a very low number of sides and the shape is irregular and smaller than a square, that it’s fitted to that square, which makes the size of the shape more predictable. Other kinds of brushes Not all kinds of generated brushes are 2D shapes being extrapolated. Right now only spheres fall into this category, but more planned shapes fall into this category. Sphere The sphere is created by clicking on a surface to determine the center of the sphere, and then dragging it out to get the radius of the sphere. If you toggle “Hemisphere” it’ll create a hemisphere instead of a sphere, with the bottom aligned with the surface you created the center point on. The “Smooth shading” toggle allows you to set if you want the sphere or hemisphere to look smooth, by turning normal smoothing on on all its surfaces, or faceted. In the tool window, after you’ve created the sphere or hemisphere you can adjust the radius manually in “radius” text field. The sphere is created by splitting the sides of a cube multiple times and placing these points on a mathematical the sphere. These splits are done in multiple directions. So when in the tool window, you set splits to one, each side of this cube will be split into 4 quads, that themselves are split into 2 triangles. You can increase the splits to make the sphere or hemisphere more smooth. The Mesh edit mode In this mode you can edit the control mesh of the brushes. You can select vertices, edges and polygons by clicking on them. If you hold the ctrl key while clicking on them you can toggle the selection on or off. You can also use a drag rectangle to select everything that’s inside the rectangle (see the “Marquee selection” section of selection and placement ). Once selected you can manipulate these vertices, edges and polygons to change the shape. Keep in mind that this shape will only be valid if it’s convex (see what are brushes? ). Invalid brushes will show up with a red outline and will snap back to their last correct shape when no longer selected. If you press delete all selected vertices will be deleted. If the resulting shape is invalid, the whole shape will be deleted. If you press M while selecting an edge, then the vertices of that edge will be moved to the center of this edge and merged. If you click on the “Flip” X/Y/Z buttons the selected brushes will be mirrored on the X/Y or Z axis around the center of the selected brushes. The “Snap to grid” button will snap all selected vertices to the grid line closest to all vertices. When the transform tool is set to then you can move your selection. You can merge vertices together by moving them on top of each other, the edge between them will be removed. You can go to this mode by pressing the standard unity hotkey W. When the transform tool is set to then you can rotate your selection. You can go to this mode by pressing the standard unity hotkey E. When the transform tool is set to or then you can scale your selection. You can use the standard unity hotkeys R (scale) and T (rect) for this If you hold shift while dragging a polygon, then you can extrude the polygon into another brush. See the “free-draw” section in generate edit mode for more details. If you hold shift while dragging an edge or vertex then you will bevel/chamfer this edge or vertex instead. The further you drag, the wider the bevel/chamfer will be. The default material in the tool window will be used for the new surfaces created by the beveling/chamfering. The Clip edit mode This edit mode is here to easily split or clip a brush or multiple brushes by an infinite plane that you define by first putting the mouse down on a surface and then dragging it over that surface to create a plane that intersects that line. After this you will see two points that you can then manipulate to change the plane. You can also click after this to create a third plane for more precise control over the splitting plane. The tool window will show three options on how to use the clipping plane, “Remove in front” / “Remove behind” which will let you specify which side of the plane will remove (parts of the) brushes, or “Split” that will create a new brush for each (part of each) brush that is removed. The tool window also shows the default material to use for the new surface area that is created when splitting or clipping brushes.If you’re satisfied with your result you can click on Commit (or press the hotkey Enter), otherwise you can press “Cancel” (or press the hotkey Escape). The Surface edit mode In this edit mode you can modify the texturing of the surfaces of your brushes. You can click to select your surfaces. If you hold control while clicking you can toggle the selection of your surfaces. If you hold shift and hold your left mouse button then you can select all the surfaces that will be underneath your mouse while you move your mouse. The tool window shows the material of the current selected surface and allows you to change it. You can manually change the offset, scale and rotation of your texture in the tool window. The -90/+90 buttons are shortcut buttons to quickly rotate your texture by 90 degrees in case it’s sideways or upside-down. The “UV-Justify” buttons try to align the texture to particular corners of your surfaces. The “C” button centers your texture on your surface. The “Fit” buttons will try to make sure that the scale and position of your texture will fit as tightly as possible on your surface. You can choose to only do this in the U or V direction, or both (UV). The “Reverse” buttons will reverse the direction of your texturing in the U, V or both UV directions. The “Reset” buttons will use the default texture coordinates in the U, V or both UV directions. The “UV scale” buttons allow you to quickly multiply the scale by 2, or divide it by 2. The “Discard” button will essentially mark a surface as not being part of the final mesh created for the model this brush in it. It will not be rendered or be part of the collision mesh. The “Shadow-Only” is like the “Discard” button except that it’ll still cast shadows. The “Visible” button will make the surface behave like a regular surface again. Note that if you cannot see your surface you can always turn on discarded or shadow-only surfaces in the helper surfaces pop-up to make Real Time-CSG render them. See the scene view for more details. The “Smooth” button will make a surface smooth the normals between all the currently selected surfaces, “Un-smooth” reverses this process. Surfaces are not smoothed by default. The “Lock texture to object” toggle ensures that when you move a surface around in the world it’s texture coordinates will move with it, otherwise the texturing will stay in the same spot even when the surface is moving. You can copy a surface from one surface to another by holding the G key and clicking on the first surface to ‘get’ the material, and then every next surface you click on will copy the previous material. If you drag your mouse over multiple surface while holding the G key then the surface materials underneath your mouse will ‘smear’ into each other, making sure that the textures are correctly rotated/scaled and moved to avoid seams. When the transform tools are set to then you can drag the texture over the surface of your brushes. Keep in mind that this movement is snapped to the grid. Note: Texture coordinates repeat over every whole number, meaning that if your snapping is set to 1 then you won’t see any changes when moving your texture over the grid. If you turn off snapping, or decrease the snapping size you can then move the texture. surface texture rotation When the transform tools are set to then when you click on the surface of your brush, and then drag outwards, a circle will appear. When you then move your mouse around that circle your texture will rotate around that original point, following your mouse. Model settings and tools The model holds all the meshes that are generated by all the brushes and operations that are inside it. At runtime all the brushes and operations are removed. Usually the meshes that are inside the model are hidden to reduce the clutter, but if you want to inspect them you can use toggle the “Show Meshes” checkbox. Keep in mind that these meshes will be updated and you should not try to modify them yourself since all your changes will be overwritten eventually. If you want to generate a mesh without a color channel, without tangents, normals or an UV1 channel, then you can use the checkboxes to avoid those channels to be generated. Usually you want to keep those around however. At the bottom you can see some quick statistics on all the brushes in your model. Note: When the model’s “Lightmap Static” flag is set, the lightmap UVs are automatically updated about a second after you’ve stopped modifying the model. Real Time-CSG calls a Unity method here that creates the lightmap UVs for the modified meshes, which is unfortunately somewhat slow. Note: All model flags and tags are automatically assigned to its meshes. Behaviour This section has a single option called “Inverted world” which will make the whole model solid by default. This allows you to subtract from the world instead of add to it. This is useful for when your entire level is, for instance, underground and you don’t need to have the outer shell for your geometry. Physics In this section you can determine how the generated meshes interact with physics. If the “Generate Collider” toggle is set a collider is generated for all the visible geometry. If you then also set “Model is trigger” then the trigger toggle will be set on the collider. If you wish the collider to be convex you can toggle the “Convex Collider” setting. Note if you’ve set the “Model Is Trigger” setting then for performance reasons, it is recommended that you also set the “Convex Collider” setting. If you set the “Auto RigidBody” toggle, a RigidBody will automatically, when necessary, be created or destroyed for all the generated colliders, and all the appropriate default settings will be set for various scenarios. The “Default Physics Material” allows you to set the physics material for all the created colliders. In a future version physics materials will be settable per surface. Rendering A model might not need to be drawn if it’s an invisible collider or a trigger. If you toggle the “Do Not Render” setting, then the model will not create MeshRenderers for this model so will not be visible. In the “Cast Shadows” drop down you can determine how shadows will interact with this model. Here you can turn shadows off, or make the mesh double sided for shadow rendering. Or set the whole model to be shadow casting only. Note that you can also set individual surfaces to be shadow only, see the surface edit mode for more details. Finally there’s the “Receive Shadows” toggle that allows you to turn shadows showing up on your model on or off. Note that some of these settings will make your model invisible, but you can still see your invisible model in the editor if you turn on the appropriate helper surfaces (see the scene view for more details). Lighting In the lighting section of the model inspector there is currently one option “Preserve UVs” which will set the similarly named setting in the lighting window for you on all your meshes. More lighting options will be added in this section over time. If you need any particular functionality, be sure to request it in the feedback site . Exporting In this section of the model inspector you can export your model to several formats by choosing your desired format from the dropdown and clicking on the “Export to ..” button. Once exported your model will be replaced by whatever you exported your model to. Also a “CSG model exported” component is added to the gameobject that held your model, which will remember the original CSG model for you. The original CSG model and all its operations and brushes are still there, they’re all hidden from you to avoid the clutter. These will automatically be removed at build time, so you won’t pay any cost for them at runtime. If you want to revert to your original CSG model, you can click on “Revert back to CSG model”. If you choose to remove your original CSG model permanently you can click on “Remove hidden CSG model”. A text based FBX file This is a common format used by DCC (Digital Content Creation) tools and allows you to load your mesh into another package such as Maya or 3DS max, edit it, and let Unity re-import it. The FBX will be instantiated into the model, replacing the CSG model, which will be hidden and removed at built time. If you update the FBX file outside of unity, then this FBX instance will be updated in your scene. A scene stored Unity mesh The scene based Unity mesh is useful if you want to edit the mesh with another asset from the asset store. Keep in mind that this mesh is stored in your scene itself . Unfortunately this means it will not work if you try to create a prefab out of this. This is unfortunately a Unity limitation."
  },
  "documentation/CSGTrees.html": {
    "href": "documentation/CSGTrees.html",
    "title": "Building CSG trees from code | RealtimeCSG",
    "keywords": "Building CSG trees from code This page is a work in progress . It will be updated within the next weeks. For the time being, here's an example instead: // Every node can have its own unique ID, this can be used to identify nodes const int treeUserID = 1; const int branchUserID = 2; const int brushAUserID = 3; const int brushBUserID = 4; const int brushMeshUserID = 5; // Create a cube BrushMesh that we can use for our brushes BrushMeshInstance cube = CreateCube(userID: brushMeshUserID); // Create a matrix for each brush, each with a different position Matrix4x4 brushPositionA = Matrix4x4.TRS(new Vector3(-0.5f, 0, 0), Quaternion.identity, Vector3.one); Matrix4x4 brushPositionB = Matrix4x4.TRS(new Vector3( 0.5f, 0, 0), Quaternion.identity, Vector3.one); // Create two brushes CSGTreeBrush brushA, brushB; brushA = CSGTreeBrush.Create(userID: brushAUserID, localTransformation: brushPositionA, brushMesh: cube, operation: CSGOperationType.Additive, flags: CSGTreeBrushFlags.Default); brushB = CSGTreeBrush.Create(userID: brushBUserID, localTransformation: brushPositionB, brushMesh: cube, operation: CSGOperationType.Subtractive, flags: CSGTreeBrushFlags.Default); // Create a branch that contains both brushes CSGTreeBranch branch; branch = CSGTreeBranch.Create(userID: branchUserID, operation: CSGOperationType.Additive, // children of this branch: children: new CSGTreeNode[] { brushA, brushB }); // Create a tree that contains the branch CSGTree tree; tree = CSGTree.Create(userID: treeUserID, children: new CSGTreeNode[] { branch }); Note: See \" Brush Meshes \" for the CreateCube example Note: See \" Create Unity Mesh \" on how to create a Unity Mesh from this tree"
  },
  "documentation/brushMesh.html": {
    "href": "documentation/brushMesh.html",
    "title": "Brush Meshes | RealtimeCSG",
    "keywords": "Brush Meshes This page is a work in progress . It will be updated within the next weeks. For the time being, here's an example on how to build a brush mesh cube instead: BrushMesh cube = RealtimeCSG.Legacy.BrushFactory.CreateCube(Vector3.one); BrushMeshInstance cubeMeshInstance = BrushMeshInstance.Create(cube, userID); Note: See \" CSG Trees \" on how to create a CSG tree using the created BrushMeshInstance"
  },
  "index.html": {
    "href": "index.html",
    "title": "Updates | RealtimeCSG",
    "keywords": "realtime CSG Updates CHECK IF YOU HAVE THE LATEST VERSION! You can download if you have purchased. Evaluate Version 1.522 UNITY 5.6 PACKAGE UNITY 2017.1 PACKAGE UNITY 2017.2 PACKAGE UNITY 2017.3 PACKAGE UNITY 2018.1 PACKAGE Limited to 100 brushes No source code / No API Contact Email Twitter Mastadon Unity Forum Requests & Bugs Lightning fast level design & prototyping tool When designing or prototyping levels you want to iterate often and get feedback fast You want to be able to easily change things without having to worry about the consequences, you never want to redo lots of work because you changed you mind, you want a non-destructive workflow . The last thing you want is wasting time working at the triangle/polygon level when you're still figuring things out! CSG allows you to focus on the design of the level and not have to worry about the details until you choose to Intuitive workflow Just drag in that prefabed door that you've created, including the hole for the door in the wall Don't like the placement of that door? Just move it in one motion and the hole will move with it Changed your mind? Just press delete, done! You can keep tweaking safely until the very end of your project CSG works with solid primitives, so you never have to worry about gaps in your geometry and your collision meshes will be created automatically Modeling with brushes With realtime CSG you can create your levels by combining brushes (simple primitives you can edit) that are either additive, subtractive or intersecting. The hierarchy defines the shape Conceptually, the final mesh is created by Realtime-CSG by going through the hierarchy from top to bottom, adding, subtracting or intersecting brushes with each other. All brushes are part of a model. Draw your brushes Simply hold V and create an outline by clicking in the scene. Release V and drag the center to extrude your 2D shape into a 3D brush. If you draw your outline on top of other brushes the newly generated shape will match the materials from that underlying brush. Curved shapes Double click on edges and vertices to toggle it between being a straight line and a curved line. Drag the handles around to control the shape of the curve Create on any surface You can create all the shapes on any surface. If you drag your shape into an existing surface it will automatically turn it into a subtractive brush for you. Creating doors and windows has never been easier. Create cylinders If you hold C instead, you can easily create cylinders. You can adjust all kinds of parameters in the helper menu that shows up while creating the cylinder. This allows you to set the radius, height of the cylinder box manually Create boxes If you hold B, you can draw boxes. You can adjust all kinds of parameters in the helper menu that shows up while creating the box. This allows you to set the width,height and depth of the box manually. Quickly create stairs Simply drag out the space the stairs need to occupy and adjust the slope. The step height can be edited manually and won't be modified by adjusting the slope, this way your step sizes remain under your control. Drag your brushes When you left click your mouse on a brush and then hold your mouse button while dragging, you can move your selected brushes around on the grid. Drag copy support If you hold D and then drag your brush, you will drag a copy of your brush instead. Works well with prefabs With realtime-CSG you can easily make prefabs that automatically update the scene when modified. When you drag & drop a prefab and drag it into the scene the prefab will automatically be placed on and rotate with the underlying geometry. The model is your mesh All the brushes belong to a model, which generates the final mesh that ends up in your game. All the brushes underneath it in the hierarchy will belong to this model, unless there's another model within the model. The settings on the model component allow you to define how this mesh will be behave in your game. Export to fbx If you prefer to do your finishing touches in your favorite DCC package you can export your CSG model to an FBX file. Your in scene CSG model will automatically be swapped with your exported mesh so that when you change the FBX, it'll be reflected in the scene. Don't worry, you will always have the option to revert back to the original CSG model. It's also possible convert your model to an Unity mesh directly instead. Operations allow you to group things The Operation component allows you to group brushes together and do CSG operations on more complicated shapes. You can group selected brushes underneath an operation by pressing Cmd/Ctrl-G. Operations define sub-shapes The operation component lets you define sub-shapes. In this case a cylinder minus another cylinder. These sub-shapes can then be added, removed or intersected with other parts of the model. Pass-through behaves as if there is no operation component. Treat groups of brushes as a single object If you want to group multiple brushes in one single object you can put them under an operation and check \"select on child\" in it's options. Now every time you select one of it's brushes you'll select the whole operation. Deep clicking If you need to select a brush on a position where multiple brushes overlap you can simply click multiple times to get the brush you want. Snap to the grid The grid visually shows you where your brushes will snap when you move them. In local mode grid is relative to parent If the parent of the brush you're moving is rotated, the grid will also be rotated when Unity is in local mode. Edit your brushes When in Edit-Mode you can easily move the vertices of your brush in any position you want them to be. You can delete selected vertices by pressing the Delete key on your keyboard. Multi selection You can also select multiple vertices or edges on multiple brushes and drag them together. Move any surface By dragging the green points you can move any surface where you want them to be. If you ALT-click on a surface dot instead you can extrude the polygon. Move surface in its facing direction If you drag your surfaces while pressing shift it'll move into the direction it's facing. Rotate any surface If the unity rotation tool is selected and you are in mesh mode, you can rotate the current edges/vertices and polygons. Scale any surface If the unity scale tool is selected and you are in mesh mode, you can scale the current edges/vertices and polygons. Chamfer/bevel any vertex or edge While in mesh mode, if you drag a vertex or edge while holding shift you will chamfer all selected vertices/edges. Clip your brush In clip-mode you can simply drag along a surface of a brush and all the selected brushes will be cut along the plane that is formed there. Clip multiple brushes If you select multiple brushes, all of these brushes will be clipped by the same plane. Tweak your clipping In the little helper menu in the bottom right corner of your view you can decide which side(s) of the plane needs to stick around and which side needs to be removed. Rotate over edges In both object-mode and mesh-mode, when you use select the unity rotate tool , you can rotate your brush by dragging the edge of the brush into a circle. Scale by dragging In object-mode you can also scale your brushes by moving the sides of the bounding box around your brushes. Scale into a negative size allows you to mirror your selection Multiple brushes at the same time Just select the brushes you want to work with, and you can scale/rotate/move etc. them together. Drag materials on surfaces Just drag and drop the materials on the brush sides you want them to be on. If you selected multiple surfaces the material will be applied to all of them. Copy and smear materials In surface-mode, after you select a surface, you can press G onto another surface to copy your material to another surface. If you hold G and drag over multiple surfaces it'll make the texture coordinates flow over those surfaces. This even works when surfaces are not connected! Select materials by dragging In surface-mode you can select your surfaces by just dragging over them while holding control, shift or alt to remove/add surfaces from/to the selection. Rotate materials If Unity is in rotate mode You can press your mouse where you want to rotate your texture coordinates around, pull and just rotate around it. Move materials If Unity is in move mode You can press your mouse and just drag your texture over the surface of your brush Note that the texture is also snapped to the grid if snapping is on and this may make it look like it's moving in a different direction, even though it's not. Smooth between surfaces If you want to smooth between multiple surfaces, just select them and press smooth in the surface-mode helper menu. Do you want them to be facetted instead? No problem, just press the un-smooth button. Discard unnecessary surfaces Sometimes you do not want certain surfaces to end up in your runtime, fortunately you can simply select and discard them."
  },
  "api/RealtimeCSG.Foundation.BrushMesh.html": {
    "href": "api/RealtimeCSG.Foundation.BrushMesh.html",
    "title": "Class BrushMesh | RealtimeCSG",
    "keywords": "Class BrushMesh Contains a shape that can be used to initialize and update a CSGTreeBrush . Inheritance Object BrushMesh Syntax [Serializable] public sealed class BrushMesh Remarks See the Brush Meshes article for more information. note This struct is safe to serialize. note This struct is mirrored on the native side and cannot be modified. Fields halfEdges Declaration public BrushMesh.HalfEdge[] halfEdges Field Value BrushMesh.HalfEdge [] An array of BrushMesh.HalfEdge that define the edges of a BrushMesh . polygons Declaration public BrushMesh.Polygon[] polygons Field Value BrushMesh.Polygon [] An array of BrushMesh.Polygon that define the polygons of a BrushMesh . vertices Declaration public Vector3[] vertices Field Value Vector3 [] The vertices of this BrushMesh . See Also BrushMeshInstance Create(BrushMesh, Int32) Set(BrushMesh) CSGTreeBrush"
  },
  "api/RealtimeCSG.Foundation.CSGTreeNode.html": {
    "href": "api/RealtimeCSG.Foundation.CSGTreeNode.html",
    "title": "Struct CSGTreeNode | RealtimeCSG",
    "keywords": "Struct CSGTreeNode Represents a generic node in a CSG tree. This is used to be able to store different types of nodes together. Syntax public struct CSGTreeNode Remarks note This struct is a reference to node that exists on the native side, therefore it is not persistent. note This struct can be converted into a CSGTreeBrush , CSGTreeBranch or CSGTree depending on what kind of node is stored in the CSGTreeNode . The type of node can be queried by using Type . If a CSGTreeNode is cast to the wrong kind of node, an invalid node is generated. note Be careful when keeping track of CSGTreeNode s because BrushMeshID s can be recycled after being Destroyed. Fields InvalidNode Declaration public static readonly CSGTreeNode InvalidNode Field Value CSGTreeNode An invalid node Properties Count Declaration public int Count { get; } Property Value Int32 Gets the number of elements contained in the CSGTreeBranch . Dirty Declaration public bool Dirty { get; } Property Value Boolean Returns the dirty flag of the CSGTreeNode . Item[Int32] Gets child at the specified index. Declaration public CSGTreeNode this[int index] { get; } Parameters Int32 index The zero-based index of the child to get. Property Value CSGTreeNode The element at the specified index. NodeID Declaration public int NodeID { get; } Property Value Int32 Gets the NodeID of the CSGTreeNode , which is a unique ID of this node. Remarks note NodeIDs are eventually recycled, so be careful holding on to Nodes that have been destroyed. Parent Declaration public CSGTreeBranch Parent { get; } Property Value CSGTreeBranch Returns the parent CSGTreeBranch this CSGTreeNode is a child of. Returns an invalid node if it's not a child of any CSGTreeBranch . Tree Declaration public CSGTree Tree { get; } Property Value CSGTree Returns tree this CSGTreeNode belongs to. Type Declaration public CSGNodeType Type { get; } Property Value CSGNodeType Gets the node-type of this CSGTreeNode . UserID Declaration public int UserID { get; } Property Value Int32 Gets the UserID set to the CSGTreeNode at creation time. Valid Declaration public bool Valid { get; } Property Value Boolean Returns if the current CSGTreeNode is valid or not. Remarks note If Valid is false that could mean that this node has been destroyed. Methods ChildrenToArray() Copies the CSGTreeNode s of the CSGTreeBranch to a new array. Declaration public CSGTreeNode[] ChildrenToArray() Returns CSGTreeNode [] An array containing the CSGTreeNode s of the CSGTreeBranch . Destroy() Destroy this CSGTreeNode . Sets the state to invalid. Declaration public bool Destroy() Returns Boolean true on success, false on failure Encapsulate(Int32) Creates a CSGTreeNode from a given nodeID. Declaration public static CSGTreeNode Encapsulate(int id) Parameters Int32 id ID of the node to create a CSGTreeNode from Returns CSGTreeNode A CSGTreeNode with the givenID. If the ID is not known on the native side, this will result in an invalid CSGTreeNode . SetDirty() Force set the dirty flag of the CSGTreeBrush . Declaration public void SetDirty() Operators Explicit(CSGTreeNode to CSGTree) Operator to allow a CSGTreeNode to be explicitly converted into a CSGTree . Declaration public static explicit operator CSGTree(CSGTreeNode node) Parameters CSGTreeNode node The CSGTreeNode to be convert into a CSGTree Returns CSGTree A valid CSGTree if node actually was one, otherwise an invalid node. Explicit(CSGTreeNode to CSGTreeBranch) Operator to allow a CSGTreeNode to be explicitly converted into a CSGTreeBranch . Declaration public static explicit operator CSGTreeBranch(CSGTreeNode node) Parameters CSGTreeNode node The CSGTreeNode to be convert into a CSGTreeBranch Returns CSGTreeBranch A valid CSGTreeBranch if node actually was one, otherwise an invalid node. Explicit(CSGTreeNode to CSGTreeBrush) Operator to allow a CSGTreeNode to be explicitly converted into a CSGTreeBrush . Declaration public static explicit operator CSGTreeBrush(CSGTreeNode node) Parameters CSGTreeNode node The CSGTreeNode to be convert into a CSGTreeBrush Returns CSGTreeBrush A valid CSGTreeBrush if node actually was one, otherwise an invalid node. Implicit(CSGTree to CSGTreeNode) Operator to implicitly convert a CSGTree into a CSGTreeNode . Declaration public static implicit operator CSGTreeNode(CSGTree tree) Parameters CSGTree tree The CSGTree to convert into a CSGTreeNode . Returns CSGTreeNode A CSGTreeNode containing the same NodeID as tree Remarks This can be used to build arrays of CSGTreeNode 's that contain a mix of type of nodes. Implicit(CSGTreeBranch to CSGTreeNode) Operator to implicitly convert a CSGTreeBranch into a CSGTreeNode . Declaration public static implicit operator CSGTreeNode(CSGTreeBranch branch) Parameters CSGTreeBranch branch The CSGTreeBranch to convert into a CSGTreeNode . Returns CSGTreeNode A CSGTreeNode containing the same NodeID as branch Remarks This can be used to build arrays of CSGTreeNode 's that contain a mix of type of nodes. Implicit(CSGTreeBrush to CSGTreeNode) Operator to implicitly convert a CSGTreeBrush into a CSGTreeNode . Declaration public static implicit operator CSGTreeNode(CSGTreeBrush brush) Parameters CSGTreeBrush brush The CSGTreeBrush to convert into a CSGTreeNode . Returns CSGTreeNode A CSGTreeNode containing the same NodeID as brush Remarks This can be used to build arrays of CSGTreeNode 's that contain a mix of type of nodes. See Also CSGTree CSGTreeBranch CSGTreeBrush"
  },
  "api/RealtimeCSG.Foundation.UVMatrix.html": {
    "href": "api/RealtimeCSG.Foundation.UVMatrix.html",
    "title": "Struct UVMatrix | RealtimeCSG",
    "keywords": "Struct UVMatrix A 2x4 matrix to calculate the UV coordinates for the vertices of a BrushMesh . Syntax [Serializable] public struct UVMatrix Remarks note This struct is mirrored on the native side and cannot be modified. Fields U Declaration public Vector4 U Field Value Vector4 Used to convert a vertex coordinate to a U texture coordinate V Declaration public Vector4 V Field Value Vector4 Used to convert a vertex coordinate to a V texture coordinate See Also BrushMesh.Polygon BrushMesh"
  },
  "api/RealtimeCSG.Legacy.Shape.html": {
    "href": "api/RealtimeCSG.Legacy.Shape.html",
    "title": "Class Shape | RealtimeCSG",
    "keywords": "Class Shape Defines the Surface s and its properties for a ControlMesh . Inheritance Object Shape Syntax [Serializable] public sealed class Shape Remarks note This code is legacy and will be removed eventually. Fields Surfaces Declaration public Surface[] Surfaces Field Value Surface [] An array of Surface s, one for each polygon. Remarks Surface are used to store information about the orientation of the polygons that are associated with this surface. TexGenFlags Declaration public TexGenFlags[] TexGenFlags Field Value TexGenFlags [] An array of TexGenFlags s, one for each polygon. Remarks TexGenFlags are used to define if a polygon is visible, part of a collision mesh etc. TexGens Declaration public TexGen[] TexGens Field Value TexGen [] An array of TexGen s, one for each polygon. Remarks TexGen are used to generate texture coordinates for the polygons that are associated with this surface. Version Declaration public float Version Field Value Single Version of the Shape See Also ControlMesh Surface TexGen TexGenFlags"
  },
  "api/RealtimeCSG.Foundation.BrushMeshUtility.html": {
    "href": "api/RealtimeCSG.Foundation.BrushMeshUtility.html",
    "title": "Class BrushMeshUtility | RealtimeCSG",
    "keywords": "Class BrushMeshUtility This class holds functionality to create and modify BrushMesh es Inheritance Object BrushMeshUtility Syntax public sealed class BrushMeshUtility Methods CreateCube(UnityEngine.Vector3, SurfaceLayers, SurfaceFlags) Creates a cube BrushMesh with size and layers and optional surfaceFlags Declaration public static BrushMesh CreateCube(UnityEngine.Vector3 size, SurfaceLayers layers, SurfaceFlags surfaceFlags = SurfaceFlags.None) Parameters UnityEngine.Vector3 size The size of the cube SurfaceLayers layers The SurfaceLayers that define how the surfaces of this cube are rendered or if they need to be part of a collider etc. SurfaceFlags surfaceFlags Optional flags that modify surface behavior. Returns BrushMesh A BrushMesh on success, null on failure Remarks note These methods are a work in progress and may change somewhat over time CreateCube(UnityEngine.Vector3, UnityEngine.Vector3, SurfaceLayers, SurfaceFlags) Creates a cube BrushMesh with bounds defined by min and max , its layers and optional surfaceFlags Declaration public static BrushMesh CreateCube(UnityEngine.Vector3 min, UnityEngine.Vector3 max, SurfaceLayers layers, SurfaceFlags surfaceFlags = SurfaceFlags.None) Parameters UnityEngine.Vector3 min The corner of the cube with the smallest x,y,z values UnityEngine.Vector3 max The corner of the cube with the largest x,y,z values SurfaceLayers layers The SurfaceLayers that define how the surfaces of this cube are rendered or if they need to be part of a collider etc. SurfaceFlags surfaceFlags Optional flags that modify surface behavior. Returns BrushMesh A BrushMesh on success, null on failure Remarks note These methods are a work in progress and may change somewhat over time"
  },
  "api/RealtimeCSG.Foundation.MeshQuery.html": {
    "href": "api/RealtimeCSG.Foundation.MeshQuery.html",
    "title": "Struct MeshQuery | RealtimeCSG",
    "keywords": "Struct MeshQuery Describes what surface parameters, and optionally which surface parameter, to query for in a model, to create a mesh. Syntax [Serializable] public struct MeshQuery Remarks See the Create Unity Meshes article for more information. note This struct is mirrored on the native side and cannot be modified. Constructors MeshQuery(LayerUsageFlags, LayerUsageFlags, LayerParameterIndex, VertexChannelFlags) Constructs a MeshQuery to use to specify which surfaces should be combined into meshes, and should they be subdivided by a particular layer parameter index. Declaration public MeshQuery(LayerUsageFlags query, LayerUsageFlags mask = LayerUsageFlags.None, LayerParameterIndex parameterIndex = LayerParameterIndex.None, VertexChannelFlags vertexChannels = VertexChannelFlags.Position) Parameters LayerUsageFlags query Which layer combination would we like to look for and generate a mesh with. LayerUsageFlags mask What layers do we ignore, and what layers do we include in our comparison. When this value is None , mask is set to be equal to query . LayerParameterIndex parameterIndex Which parameter index we use to, for example, differentiate between different UnityEngine.Material s VertexChannelFlags vertexChannels Which vertex channels need to be used for the meshes we'd like to generate. See Also SurfaceLayers Properties LayerParameterIndex Declaration public LayerParameterIndex LayerParameterIndex { get; set; } Property Value LayerParameterIndex Which parameter index we use to, for example, differentiate between different UnityEngine.Material s. See Also LayerParameterIndex SurfaceLayers BrushMesh.Polygon LayerQuery Declaration public LayerUsageFlags LayerQuery { get; set; } Property Value LayerUsageFlags Which layer combination would we like to look for and generate a mesh with See Also SurfaceLayers BrushMesh.Polygon LayerQueryMask Declaration public LayerUsageFlags LayerQueryMask { get; set; } Property Value LayerUsageFlags What layers do we ignore, and what layers do we include in our comparison See Also SurfaceLayers BrushMesh.Polygon UsedVertexChannels Declaration public VertexChannelFlags UsedVertexChannels { get; set; } Property Value VertexChannelFlags Which vertex channels need to be used for the meshes we'd like to generate See Also GetMeshDescriptions(MeshQuery[], VertexChannelFlags) See Also SurfaceLayers BrushMesh.Polygon LayerUsageFlags LayerParameterIndex GetMeshDescriptions(MeshQuery[], VertexChannelFlags)"
  },
  "api/RealtimeCSG.Legacy.CSGPlane.html": {
    "href": "api/RealtimeCSG.Legacy.CSGPlane.html",
    "title": "Struct CSGPlane | RealtimeCSG",
    "keywords": "Struct CSGPlane A geometric plane Syntax [Serializable] public struct CSGPlane Remarks note This code will be replaced by UnityEngine.Plane eventually. In older versions of Realtime-CSG UnityEngine.Plane , Unity's own Plane, was not serializable and wasn't an option. note This class can be safely serialized. Constructors CSGPlane(Single, Single, Single, Single) Create a plane by giving the plane equation ax+by+cz-d=0. Declaration public CSGPlane(float inA, float inB, float inC, float inD) Parameters Single inA a in the plane equation: ax+by+cz-d=0 Single inB b in the plane equation: ax+by+cz-d=0 Single inC c in the plane equation: ax+by+cz-d=0 Single inD d in the plane equation: ax+by+cz-d=0 CSGPlane(UnityEngine.Quaternion, Vector3) Create a plane with a point and a quaternion Declaration public CSGPlane(UnityEngine.Quaternion inRotation, Vector3 pointOnPlane) Parameters UnityEngine.Quaternion inRotation The orientation of the plane Vector3 pointOnPlane The position of the plane CSGPlane(Vector3, Single) Create a plane with a normal and the distance to the origin Declaration public CSGPlane(Vector3 inNormal, float inD) Parameters Vector3 inNormal The normal of the plane Single inD The distance to the origin CSGPlane(Vector3, Vector3) Create a plane with a point and a normal Declaration public CSGPlane(Vector3 inNormal, Vector3 pointOnPlane) Parameters Vector3 inNormal The normal of the plane Vector3 pointOnPlane The position of the plane CSGPlane(Vector3, Vector3, Vector3) Calculate a plane from 3 points Declaration public CSGPlane(Vector3 point1, Vector3 point2, Vector3 point3) Parameters Vector3 point1 First point Vector3 point2 Second point Vector3 point3 Third point Fields a Declaration public float a Field Value Single a in the plane equation: ax+by+cz-d=0 b Declaration public float b Field Value Single b in the plane equation: ax+by+cz-d=0 c Declaration public float c Field Value Single c in the plane equation: ax+by+cz-d=0 d Declaration public float d Field Value Single d in the plane equation: ax+by+cz-d=0 Properties normal Declaration public Vector3 normal { get; set; } Property Value Vector3 Gets or sets the normal of this plane pointOnPlane Declaration public Vector3 pointOnPlane { get; } Property Value Vector3 Point on the plane Methods Distance(Vector3) Calculates the distance to a point to this plane Declaration public float Distance(Vector3 point) Parameters Vector3 point A point Returns Single The distance from the point to the plane Intersection(CSGPlane, CSGPlane, CSGPlane) Calculates the intersection point between 3 planes Declaration public static Vector3 Intersection(CSGPlane inPlane1, CSGPlane inPlane2, CSGPlane inPlane3) Parameters CSGPlane inPlane1 The first plane CSGPlane inPlane2 The second plane CSGPlane inPlane3 The third plane Returns Vector3 The intersection point between the 3 planes.The returned point will consist out NaN values when there is no intersection. LineIntersection(Vector3, Vector3) Calculates an intersection between a line and the plane Declaration public Vector3 LineIntersection(Vector3 start, Vector3 end) Parameters Vector3 start Start of the line Vector3 end End of the line Returns Vector3 Intersection point Negated() Creates a copy of this plane that has its direction inverted Declaration public CSGPlane Negated() Returns CSGPlane A new plane that is flipped Normalize() Normalize the normal of the plane Declaration public void Normalize() Project(Vector3) Project a point on this plane Declaration public Vector3 Project(Vector3 point) Parameters Vector3 point A point Returns Vector3 The projected point RayIntersection(UnityEngine.Ray) Calculate an intersection with a given ray and the plane. Declaration public Vector3 RayIntersection(UnityEngine.Ray ray) Parameters UnityEngine.Ray ray The ray to find an intersection with Returns Vector3 The intersection point. Transform(UnityEngine.Matrix4x4) Transform the plane with the given transformation Declaration public void Transform(UnityEngine.Matrix4x4 transformation) Parameters UnityEngine.Matrix4x4 transformation The transformation to transform the plane with Translated(Vector3) Translates a plane in space Declaration public CSGPlane Translated(Vector3 translation) Parameters Vector3 translation A vector to translate the plane over Returns CSGPlane A plane translated by translation TryRayIntersection(UnityEngine.Ray, out Vector3) Attempt to find an intersection with a given ray and the plane. Declaration public bool TryRayIntersection(UnityEngine.Ray ray, out Vector3 intersection) Parameters UnityEngine.Ray ray The ray to find an intersection with Vector3 intersection The intersection point, if found Returns Boolean true if we found an intersection, false if we didn't."
  },
  "api/RealtimeCSG.Legacy.html": {
    "href": "api/RealtimeCSG.Legacy.html",
    "title": "Namespace RealtimeCSG.Legacy | RealtimeCSG",
    "keywords": "Namespace RealtimeCSG.Legacy Classes BrushFactory Legacy factory class to create ControlMesh es and Shape s with ControlMesh Defines the shape of a convex brush that can be used in CSG operations. Polygon A Polygon of a ControlMesh . Shape Defines the Surface s and its properties for a ControlMesh . Structs CSGPlane A geometric plane HalfEdge A HalfEdge of a ControlMesh . Surface Defines how a surface is orientated in space, and an index to a TexGen . TexGen Defines what type of surface a surface is (Renderable, Collidable etc.) and how its texture coordinates and normals are generated. Enums TexGenFlags Flags to specify in what meshes a surface is part of TextureMatrixSpace Specifies if a matrix, used to calculate uv coordinates with, is in plane or world space"
  },
  "api/RealtimeCSG.Components.CSGBrush.html": {
    "href": "api/RealtimeCSG.Components.CSGBrush.html",
    "title": "Class CSGBrush | RealtimeCSG",
    "keywords": "Class CSGBrush Holds a CSG tree brush Inheritance Object CSGNode CSGBrush Syntax public sealed class CSGBrush : CSGNode Fields ControlMesh Declaration public ControlMesh ControlMesh Field Value ControlMesh The ControlMesh that defines the shape by this brush together with its Shape . Remarks note This will be replaced by BrushMesh eventually OperationType Declaration public CSGOperationType OperationType Field Value CSGOperationType The CSG operation to perform with this brush Shape Declaration public Shape Shape Field Value Shape The Shape that defines the shape by this brush together with its ControlMesh . Remarks note This will be replaced by BrushMesh eventually Version Declaration public float Version Field Value Single The version number of this instance of a CSGBrush"
  },
  "api/RealtimeCSG.Components.CSGOperation.html": {
    "href": "api/RealtimeCSG.Components.CSGOperation.html",
    "title": "Class CSGOperation | RealtimeCSG",
    "keywords": "Class CSGOperation Holds a CSG tree branch Inheritance Object CSGNode CSGOperation Syntax public sealed class CSGOperation : CSGNode Remarks The CSG branch that defines a CSGOperation is defined by its child UnityEngine.GameObject s. Fields OperationType Declaration public CSGOperationType OperationType Field Value CSGOperationType The CSG operation to perform with this CSG branch Version Declaration public float Version Field Value Single The version number of this instance of a CSGOperation"
  },
  "api/RealtimeCSG.Foundation.html": {
    "href": "api/RealtimeCSG.Foundation.html",
    "title": "Namespace RealtimeCSG.Foundation | RealtimeCSG",
    "keywords": "Namespace RealtimeCSG.Foundation Classes BrushMesh Contains a shape that can be used to initialize and update a CSGTreeBrush . BrushMeshUtility This class holds functionality to create and modify BrushMesh es CSGManager This class is manager class for all CSGTreeNode s. GeneratedMeshContents Stores a mesh generated by calling GetGeneratedMesh(GeneratedMeshDescription) . Structs BrushMesh.HalfEdge Defines a half edge of a BrushMesh . BrushMesh.Polygon Defines the polygon of a BrushMesh . BrushMeshInstance Represents the instance of a BrushMesh . This can be used to assign a BrushMesh to one or multiple CSGTreeBrush es. CSGTree The root of a CSG tree which is used to generate meshes with. All other types of nodes are children of this node. CSGTreeBranch A branch in a CSG tree, used to encapsulate other CSGTreeBranch es and CSGTreeBrush es and perform operations with them as a whole. CSGTreeBrush A leaf node in a CSG tree that has a shape (a BrushMesh ) with which CSG operations can be performed. CSGTreeNode Represents a generic node in a CSG tree. This is used to be able to store different types of nodes together. GeneratedMeshDescription Describes a generated mesh, that may not already have been created. MeshQuery Describes what surface parameters, and optionally which surface parameter, to query for in a model, to create a mesh. SurfaceDescription Describes how the texture coordinates and normals are generated and if a surface is, for example, Renderable and/or Collidable etc. SurfaceLayers This struct describes what layers a surface is part of, and user set layer indices UVMatrix A 2x4 matrix to calculate the UV coordinates for the vertices of a BrushMesh . Enums CSGNodeType Enum which describes the type of a node CSGOperationType Defines how the CSG operation is performed on the intersection between CSGTreeBrush es and/or CSGTreeBranch es. CSGTreeBrushFlags Flags to modify default brush behavior. LayerParameterIndex Index into one of the parameters of a SurfaceLayers LayerUsageFlags Define which layers of BrushMesh.Polygon s of BrushMesh es that should be combined to create meshes. SurfaceFlags Flags that define how surfaces in a BrushMesh behave. VertexChannelFlags Used to define which vertex channels need to be generated by a generated brush."
  },
  "api/RealtimeCSG.Components.html": {
    "href": "api/RealtimeCSG.Components.html",
    "title": "Namespace RealtimeCSG.Components | RealtimeCSG",
    "keywords": "Namespace RealtimeCSG.Components Classes CSGBrush Holds a CSG tree brush CSGModel Holds a CSG tree and generates meshes for that CSG tree CSGNode Parent class of CSGBrush / CSGOperation / CSGModel CSGOperation Holds a CSG tree branch"
  },
  "api/RealtimeCSG.Foundation.LayerParameterIndex.html": {
    "href": "api/RealtimeCSG.Foundation.LayerParameterIndex.html",
    "title": "Enum LayerParameterIndex | RealtimeCSG",
    "keywords": "Enum LayerParameterIndex Index into one of the parameters of a SurfaceLayers Syntax [Serializable] public enum LayerParameterIndex : byte Remarks Used to generate a mesh, by querying for a specific surface layer parameter index. For example, the first layer parameter could be an index to a specific Material to render, which could be used by all surface types that are renderable. note This enum is mirrored on the native side and cannot be modified. The number of LayerParameters is the same as in SurfaceLayers . LayerParameter1 Find polygons and create a mesh for each unique layerParameter1 . LayerParameter2 Find polygons and create a mesh for each unique layerParameter2 . LayerParameter3 Find polygons and create a mesh for each unique layerParameter3 . None No parameter index is used PhysicsMaterial Find polygons and create a mesh for each unique PhysicMaterial RenderMaterial Find polygons and create a mesh for each unique Material"
  },
  "api/RealtimeCSG.Foundation.SurfaceLayers.html": {
    "href": "api/RealtimeCSG.Foundation.SurfaceLayers.html",
    "title": "Struct SurfaceLayers | RealtimeCSG",
    "keywords": "Struct SurfaceLayers This struct describes what layers a surface is part of, and user set layer indices Syntax [Serializable] public struct SurfaceLayers Remarks Setting layer indices can be used to, for example, assign things like Material s and PhysicMaterial s to a surface. Currently only 3 layer indices are supported, more might be added in the future. See the Create Unity Meshes article for more information. note This struct is mirrored on the native side and cannot be modified. The number of LayerParameters is the same as in LayerParameterIndex . Fields layerParameter1 Declaration public int layerParameter1 Field Value Int32 First layer-parameter. Remarks Could be, for instance, an instanceID to a Material , which can then be found using EditorUtility.InstanceIDToObject A value of 0 means that it's not set. mySurfaceLayer. layerParameter1 = myMaterial.GetInstanceID(); ... generate your mesh ... Material myMaterial = EditorUtility.InstanceIDToObject(myGeneratedMeshContents.surfaceParameter); See Also LayerParameter1 layerParameter2 Declaration public int layerParameter2 Field Value Int32 Second layer-parameter. Remarks Could be, for instance, an instanceID to a PhysicMaterial , which can then be found using EditorUtility.InstanceIDToObject A value of 0 means that it's not set. mySurfaceLayer. layerParameter2 = myPhysicMaterial.GetInstanceID(); ... generate your mesh ... PhysicMaterial myMaterial = EditorUtility.InstanceIDToObject(myGeneratedMeshContents.surfaceParameter); See Also LayerParameter2 layerParameter3 Declaration public int layerParameter3 Field Value Int32 Third layer-parameter. Remarks A value of 0 means that it's not set. layerUsage Declaration public LayerUsageFlags layerUsage Field Value LayerUsageFlags Describe to what layers this surface belongs. Remarks Can be used to define if the surface is, for example, Renderable and/or Collidable etc. See Also BrushMesh BrushMesh.Polygon MeshQuery LayerUsageFlags LayerParameterIndex"
  },
  "api/RealtimeCSG.Legacy.Polygon.html": {
    "href": "api/RealtimeCSG.Legacy.Polygon.html",
    "title": "Class Polygon | RealtimeCSG",
    "keywords": "Class Polygon A Polygon of a ControlMesh . Inheritance Object Polygon Syntax [Serializable] public sealed class Polygon Remarks note This code will be replaced by pure BrushMesh code eventually. note This class can be safely serialized. Constructors Polygon(Int32[], Int32) Creates a Polygon for a ControlMesh Declaration public Polygon(int[] edges, int texGenIndex) Parameters Int32 [] edges A list of indices to HalfEdge s in the ControlMesh this Polygon belongs to, that form this Polygon . Int32 texGenIndex An index to the TexGen in the ControlMesh that this Polygon uses. Fields EdgeIndices Declaration public int[] EdgeIndices Field Value Int32 [] indices to HalfEdge s in the ControlMesh this Polygon belongs to. TexGenIndex Declaration public int TexGenIndex Field Value Int32 Index to the TexGen in the ControlMesh that this Polygon uses. See Also ControlMesh HalfEdge TexGen TexGenFlags Shape"
  },
  "api/RealtimeCSG.Foundation.CSGTreeBranch.html": {
    "href": "api/RealtimeCSG.Foundation.CSGTreeBranch.html",
    "title": "Struct CSGTreeBranch | RealtimeCSG",
    "keywords": "Struct CSGTreeBranch A branch in a CSG tree, used to encapsulate other CSGTreeBranch es and CSGTreeBrush es and perform operations with them as a whole. Syntax public struct CSGTreeBranch Remarks A branch can be used to combine multiple branches and/or brushes, each with different CSGOperationType s, and perform a CSG operation with the shape that's defined by all those branches and brushes on other parts of the CSG tree. note This struct is a reference to node that exists on the native side, therefore its internal ID is not persistent. note This struct can be converted into a CSGTreeNode and back again. note Be careful when keeping track of CSGTreeBranch s because BrushMeshID s can be recycled after being Destroyed. See the CSG Trees article for more information. Properties Count Declaration public int Count { get; } Property Value Int32 Gets the number of elements contained in the CSGTreeBranch . Dirty Declaration public bool Dirty { get; } Property Value Boolean Returns the dirty flag of the CSGTreeBranch . When the it's dirty, then it means (some of) its generated meshes have been modified. Item[Int32] Gets child at the specified index. Declaration public CSGTreeNode this[int index] { get; } Parameters Int32 index The zero-based index of the child to get. Property Value CSGTreeNode The element at the specified index. NodeID Declaration public int NodeID { get; } Property Value Int32 Gets the NodeID of the CSGTreeBranch , which is a unique ID of this node. Remarks note NodeIDs are eventually recycled, so be careful holding on to Nodes that have been destroyed. Operation Declaration public CSGOperationType Operation { get; set; } Property Value CSGOperationType The CSG operation that this CSGTreeBranch will use. Parent Declaration public CSGTreeBranch Parent { get; } Property Value CSGTreeBranch Returns the parent CSGTreeBranch this CSGTreeBranch is a child of. Returns an invalid node if it's not a child of any CSGTreeBranch . Tree Declaration public CSGTree Tree { get; } Property Value CSGTree Returns tree this CSGTreeBranch belongs to. UserID Declaration public int UserID { get; } Property Value Int32 Gets the UserID set to the CSGTreeBranch at creation time. Valid Declaration public bool Valid { get; } Property Value Boolean Returns if the current CSGTreeBranch is valid or not. Remarks note If Valid is false that could mean that this node has been destroyed. Methods Add(CSGTreeNode) Adds a CSGTreeNode to the end of the CSGTreeBranch . Declaration public bool Add(CSGTreeNode item) Parameters CSGTreeNode item The CSGTreeNode to be added to the end of the CSGTreeBranch . Returns Boolean true on success, false on failure AddRange(CSGTreeNode[]) Adds the CSGTreeNode s of the specified array to the end of the CSGTreeBranch . Declaration public bool AddRange(CSGTreeNode[] array) Parameters CSGTreeNode [] array The array whose CSGTreeNode s should be added to the end of the CSGTreeBranch . The array itself cannot be null. Returns Boolean true on success, false on failure ChildrenToArray() Copies the CSGTreeNode s of the CSGTreeBranch to a new array. Declaration public CSGTreeNode[] ChildrenToArray() Returns CSGTreeNode [] An array containing the CSGTreeNode s of the CSGTreeBranch . Clear() Removes all children from the CSGTreeBranch . Declaration public void Clear() Contains(CSGTreeNode) Determines whether the CSGTreeBranch contains a specific value. Declaration public bool Contains(CSGTreeNode item) Parameters CSGTreeNode item The Object to locate in the CSGTreeBranch . Returns Boolean true if item is found in the CSGTreeBranch ; otherwise, false . CopyChildrenTo(CSGTreeNode[], Int32) Copies the immediate children of the CSGTreeBranch to an Array, starting at a particular Array index. Declaration public int CopyChildrenTo(CSGTreeNode[] array, int arrayIndex) Parameters CSGTreeNode [] array The one-dimensional Array that is the destination of the elements copied from CSGTreeBranch . The Array must have zero-based indexing. Int32 arrayIndex The zero-based index in array at which copying begins. Returns Int32 The number of children copied into array . Create(CSGTreeNode[]) Generates a branch on the native side and returns a CSGTreeBranch struct that contains a reference to it. Declaration public static CSGTreeBranch Create(params CSGTreeNode[] children) Parameters CSGTreeNode [] children The child nodes that are children of this branch. A branch may not have duplicate children, contain itself or contain a CSGTree . Returns CSGTreeBranch A new CSGTreeBranch . May be an invalid node if it failed to create it. Create(Int32, CSGOperationType, CSGTreeNode[]) Generates a branch on the native side and returns a CSGTreeBranch struct that contains a reference to it. Declaration public static CSGTreeBranch Create(int userID = 0, CSGOperationType operation = CSGOperationType.Additive, params CSGTreeNode[] children) Parameters Int32 userID A unique id to help identify this particular branch. For instance, this could be an InstanceID to a UnityEngine.Object CSGOperationType operation CSGTreeNode [] children The child nodes that are children of this branch. A branch may not have duplicate children, contain itself or contain a CSGTree . Returns CSGTreeBranch A new CSGTreeBranch . May be an invalid node if it failed to create it. Create(Int32, CSGTreeNode[]) Generates a branch on the native side and returns a CSGTreeBranch struct that contains a reference to it. Declaration public static CSGTreeBranch Create(int userID, params CSGTreeNode[] children) Parameters Int32 userID A unique id to help identify this particular branch. For instance, this could be an InstanceID to a UnityEngine.Object CSGTreeNode [] children The child nodes that are children of this branch. A branch may not have duplicate children, contain itself or contain a CSGTree . Returns CSGTreeBranch A new CSGTreeBranch . May be an invalid node if it failed to create it. Destroy() Destroy this CSGTreeNode . Sets the state to invalid. Declaration public bool Destroy() Returns Boolean true on success, false on failure IndexOf(CSGTreeNode) Determines the index of a specific child in the CSGTreeBranch . Declaration public int IndexOf(CSGTreeNode item) Parameters CSGTreeNode item The CSGTreeNode to locate in the CSGTreeBranch . Returns Int32 The index of item if found in the CSGTreeBranch ; otherwise, –1. Insert(Int32, CSGTreeNode) Inserts an element into the CSGTreeNode at the specified index. Declaration public bool Insert(int index, CSGTreeNode item) Parameters Int32 index The zero-based index at which item should be inserted. CSGTreeNode item The CSGTreeNode to insert. Returns Boolean true on success, false on failure InsertRange(Int32, CSGTreeNode[]) Inserts the CSGTreeNode s of an array into the CSGTreeNode at the specified index. Declaration public bool InsertRange(int index, CSGTreeNode[] array) Parameters Int32 index The zero-based index at which the new CSGTreeNode s should be inserted. CSGTreeNode [] array The array whose CSGTreeNode s should be inserted into the CSGTreeNode . The array itself cannot be null. Returns Boolean true on success, false on failure Remove(CSGTreeNode) Removes a specific CSGTreeNode from the CSGTreeBranch . Declaration public bool Remove(CSGTreeNode item) Parameters CSGTreeNode item The CSGTreeNode to remove from the CSGTreeBranch . Returns Boolean true on success, false on failure RemoveAt(Int32) Removes the child at the specified index of the CSGTreeBranch . Declaration public bool RemoveAt(int index) Parameters Int32 index The zero-based index of the child to remove. Returns Boolean true on success, false on failure RemoveRange(Int32, Int32) Removes a range of children from the CSGTreeBranch . Declaration public bool RemoveRange(int index, int count) Parameters Int32 index The zero-based starting index of the range of children to remove. Int32 count The number of children to remove. Returns Boolean true on success, false on failure SetDirty() Force set the dirty flag of the CSGTreeNode . Declaration public void SetDirty() See Also CSGTreeNode CSGTree CSGTreeBrush"
  },
  "api/RealtimeCSG.Foundation.GeneratedMeshContents.html": {
    "href": "api/RealtimeCSG.Foundation.GeneratedMeshContents.html",
    "title": "Class GeneratedMeshContents | RealtimeCSG",
    "keywords": "Class GeneratedMeshContents Stores a mesh generated by calling GetGeneratedMesh(GeneratedMeshDescription) . Inheritance Object GeneratedMeshContents Syntax public sealed class GeneratedMeshContents Remarks See the Create Unity Meshes article for more information. GeneratedMeshContents holds the binary mesh data from the managed side and can be turned into a UnityEngine.Mesh by calling CopyTo(UnityEngine.Mesh) . See the Create Unity Meshes article for more information. Fields bounds Declaration public UnityEngine.Bounds bounds Field Value UnityEngine.Bounds Bounds of the mesh. description Declaration public GeneratedMeshDescription description Field Value GeneratedMeshDescription Describes the GeneratedMesh. Remarks This is a copy of the description used to retrieve the GeneratedMeshContents by calling GetGeneratedMesh(GeneratedMeshDescription) . indices Declaration public int[] indices Field Value Int32 [] Triangle indices to the vertices that make up the triangle. normals Declaration public UnityEngine.Vector3[] normals Field Value UnityEngine.Vector3 [] Normal for each vertex. Remarks Each BrushMesh.Polygon has a smoothingGroup field in its SurfaceDescription . If the smoothingGroup is set to something other than 0 the normal is calculated by; combining the normals of all the surfaces around each vertex that share the same smoothingGroup . If the smoothingGroup is set to 0 the normal of the polygon is used. note Can be null when the description has no normals set in its UsedVertexChannels . positions Declaration public UnityEngine.Vector3[] positions Field Value UnityEngine.Vector3 [] Position for each vertex. tangents Declaration public UnityEngine.Vector4[] tangents Field Value UnityEngine.Vector4 [] Tangent for each vertex. Remarks note Can be null when the description has no tangents set in its UsedVertexChannels . uv0 Declaration public UnityEngine.Vector2[] uv0 Field Value UnityEngine.Vector2 [] First uv channel for each vertex. Remarks These are created by multiplying the vertices of the BrushMesh , which was used to generate this geometry, by the UV0 UVMatrix of the SurfaceDescription of the vertex. note Can be null when the description has no UV0 set in its UsedVertexChannels . Methods CopyTo(UnityEngine.Mesh) Copies the contents of the generated mesh to a UnityEngine.Mesh . Declaration public void CopyTo(UnityEngine.Mesh mesh) Parameters UnityEngine.Mesh mesh The mesh to copy the GeneratedMeshContents into Remarks MeshDescription meshDescription = ... ; GeneratedMeshContents contents = tree.GetGeneratedMesh(meshDescription); UnityEngine.Mesh unityMesh = new UnityEngine.Mesh(); contents.CopyTo(unityMesh); See the Create Unity Meshes article for more information. Exceptions ArgumentNullException Thrown when mesh is null. ArgumentException Thrown when mesh is invalid. This can happen when the mesh has already been destroyed. See Also CSGTree GetGeneratedMesh(GeneratedMeshDescription) GeneratedMeshDescription SurfaceDescription UnityEngine.Mesh"
  },
  "api/RealtimeCSG.Legacy.TexGen.html": {
    "href": "api/RealtimeCSG.Legacy.TexGen.html",
    "title": "Struct TexGen | RealtimeCSG",
    "keywords": "Struct TexGen Defines what type of surface a surface is (Renderable, Collidable etc.) and how its texture coordinates and normals are generated. Syntax [Serializable] public struct TexGen Remarks note This code is legacy and will be removed eventually. Constructors TexGen(Material, PhysicMaterial) Constructor to generate TexGen Declaration public TexGen(Material renderMaterial = null, PhysicMaterial physicsMaterial = null) Parameters Material renderMaterial UnityEngine.Material to use with this TexGen PhysicMaterial physicsMaterial UnityEngine.PhysicMaterial to use with this TexGen Fields PhysicsMaterial Declaration public PhysicMaterial PhysicsMaterial Field Value PhysicMaterial UnityEngine.PhysicMaterial that is used by the polygons associated with this TexGen to generate UnityEngine.Collider with RenderMaterial Declaration public Material RenderMaterial Field Value Material UnityEngine.Material that is used by the polygons associated with this TexGen to generate UnityEngine.MeshRenderer with RotationAngle Declaration public float RotationAngle Field Value Single UV rotation relative to translated plane origin Scale Declaration public Vector2 Scale Field Value Vector2 UV scale relative to translated plane origin SmoothingGroup Declaration public uint SmoothingGroup Field Value UInt32 SmoothingGroup used to smooth normals together Remarks All normals around a vertex are averaged for all surfaces that have the same SmoothingGroup . When SmoothingGroup is 0 no smoothing is applied. Translation Declaration public Vector2 Translation Field Value Vector2 UV translation relative to plane origin Methods GeneratePlaneSpaceToTextureSpaceMatrix() Generates a matrix that converts a coordinate in plane-space to uv-space Declaration public Matrix4x4 GeneratePlaneSpaceToTextureSpaceMatrix() Returns Matrix4x4 A plane space to uv space matrix See Also Shape ControlMesh Polygon TexGenFlags"
  },
  "api/RealtimeCSG.Foundation.BrushMeshInstance.html": {
    "href": "api/RealtimeCSG.Foundation.BrushMeshInstance.html",
    "title": "Struct BrushMeshInstance | RealtimeCSG",
    "keywords": "Struct BrushMeshInstance Represents the instance of a BrushMesh . This can be used to assign a BrushMesh to one or multiple CSGTreeBrush es. Syntax public struct BrushMeshInstance Remarks See the Brush Meshes article for more information. note Be careful when keeping track of BrushMeshInstance s because BrushMeshID s can be recycled after being Destroyed. Fields InvalidInstance Declaration public static readonly BrushMeshInstance InvalidInstance Field Value BrushMeshInstance An invalid instance Properties BrushMeshID Declaration public int BrushMeshID { get; } Property Value Int32 Returns the unique id of this BrushMesh UserID Declaration public int UserID { get; } Property Value Int32 Gets the UserID set to the BrushMeshInstance at creation time. Valid Declaration public bool Valid { get; } Property Value Boolean Is the current BrushMeshInstance in a correct state Methods Create(BrushMesh, Int32) Create a BrushMeshInstance from a given BrushMesh Declaration public static BrushMeshInstance Create(BrushMesh brushMesh, int userID = 0) Parameters BrushMesh brushMesh The BrushMesh to create an instance with Int32 userID Returns BrushMeshInstance A newly created BrushMeshInstance on success, or an invalid BrushMeshInstance on failure. Destroy() Destroy the BrushMeshInstance and release the memory used by this instance. Declaration public void Destroy() Set(BrushMesh) Update this BrushMeshInstance with the given BrushMesh . Declaration public bool Set(BrushMesh brushMesh) Parameters BrushMesh brushMesh The BrushMesh to update the BrushMeshInstance with Returns Boolean true on success, false on failure. In case of failure the brush will keep using the previously set BrushMesh . See Also BrushMesh CSGTreeBrush"
  },
  "api/RealtimeCSG.Foundation.GeneratedMeshDescription.html": {
    "href": "api/RealtimeCSG.Foundation.GeneratedMeshDescription.html",
    "title": "Struct GeneratedMeshDescription | RealtimeCSG",
    "keywords": "Struct GeneratedMeshDescription Describes a generated mesh, that may not already have been created. Syntax [Serializable] public struct GeneratedMeshDescription Remarks A GeneratedMeshDescription is created by GetMeshDescriptions(MeshQuery[], VertexChannelFlags) and can then be used to initialize a UnityEngine.Mesh by calling GetGeneratedMesh(GeneratedMeshDescription) and CopyTo(UnityEngine.Mesh) . CSGTree tree = ...; MeshQuery[] meshQueries = ...; GeneratedMeshDescription[] meshDescriptions = tree.GetMeshDescriptions(meshQueries, VertexChannelFlags.All); if (meshDescriptions == null) return; foreach(var meshDescription in meshDescriptions) { GeneratedMeshContents contents = tree.GetGeneratedMesh(meshDescription); UnityEngine.Mesh unityMesh = new UnityEngine.Mesh(); contents.CopyTo(unityMesh); } See the Create Unity Meshes article for more information. note The hash values can be used to determine if an existing mesh has changed, and to decide if a new mesh should be created or not. note This struct is mirrored on the native side and cannot be modified. Fields geometryHashValue Declaration public ulong geometryHashValue Field Value UInt64 Value that can be used to detect changes in vertex positions / indices. indexCount Declaration public int indexCount Field Value Int32 Number of vertices of this generated mesh. Remarks This be used to pre-allocate arrays. meshQuery Declaration public MeshQuery meshQuery Field Value MeshQuery meshQueryIndex Declaration public int meshQueryIndex Field Value Int32 An unique index for each found meshQuery / surfaceParameter pair. subMeshQueryIndex Declaration public int subMeshQueryIndex Field Value Int32 An index for each sub-mesh for each unique meshQuery / surfaceParameter pair. Remarks Each individual generated mesh has a 64k vertex limit. When more vertices are required, multiple sub-meshes are generated. surfaceHashValue Declaration public ulong surfaceHashValue Field Value UInt64 Value that can be used to detect changes in normal, tangent or uv. surfaceParameter Declaration public int surfaceParameter Field Value Int32 If requested by the MeshQuery this hold a surface parameter, otherwise its 0. Remarks A surface parameter can be used to, for example, differentiate between meshes that use a different UnityEngine.Material . vertexCount Declaration public int vertexCount Field Value Int32 Number of vertices of this generated mesh. Remarks This can be used to pre-allocate arrays. See Also MeshQuery CSGTree GetMeshDescriptions(MeshQuery[], VertexChannelFlags) GetGeneratedMesh(GeneratedMeshDescription) GeneratedMeshContents"
  },
  "api/RealtimeCSG.Foundation.VertexChannelFlags.html": {
    "href": "api/RealtimeCSG.Foundation.VertexChannelFlags.html",
    "title": "Enum VertexChannelFlags | RealtimeCSG",
    "keywords": "Enum VertexChannelFlags Used to define which vertex channels need to be generated by a generated brush. Syntax [Serializable] [Flags] public enum VertexChannelFlags : byte Remarks note This enum is mirrored on the native side and cannot be modified. All All supported vertex channels Normal When flag is set, includes vertex normals in the generated mesh. Position When flag is set, includes vertex positions in the generated mesh. Required, always set. Tangent When flag is set, includes vertex tangents in the generated mesh. UV0 When flag is set, includes vertex uv0 channel in the generated mesh."
  },
  "api/RealtimeCSG.Legacy.Surface.html": {
    "href": "api/RealtimeCSG.Legacy.Surface.html",
    "title": "Struct Surface | RealtimeCSG",
    "keywords": "Struct Surface Defines how a surface is orientated in space, and an index to a TexGen . Syntax [Serializable] public struct Surface Remarks note This code is legacy and will be removed eventually. Fields BiNormal Declaration public Vector3 BiNormal Field Value Vector3 The binormal vector for this surface Plane Declaration public CSGPlane Plane Field Value CSGPlane The geometric Plane this surface lies on Tangent Declaration public Vector3 Tangent Field Value Vector3 The tangent vector for this surface TexGenIndex Declaration public int TexGenIndex Field Value Int32 Index to a TexGen that is in the same Shape as this Surface Methods GenerateLocalBrushSpaceToPlaneSpaceMatrix() Generates a matrix to transform from local brush space to plane space (z is up) Declaration public Matrix4x4 GenerateLocalBrushSpaceToPlaneSpaceMatrix() Returns Matrix4x4 Transformation matrix from local brush to plane space See Also Shape ControlMesh Polygon TexGen TexGenFlags"
  },
  "api/RealtimeCSG.Foundation.BrushMesh.HalfEdge.html": {
    "href": "api/RealtimeCSG.Foundation.BrushMesh.HalfEdge.html",
    "title": "Struct BrushMesh.HalfEdge | RealtimeCSG",
    "keywords": "Struct BrushMesh.HalfEdge Defines a half edge of a BrushMesh . Syntax [Serializable] public struct HalfEdge Remarks note This struct is mirrored on the native side and cannot be modified. Fields twinIndex Declaration public int twinIndex Field Value Int32 The index to the twin BrushMesh.HalfEdge of this BrushMesh.HalfEdge . vertexIndex Declaration public int vertexIndex Field Value Int32 The index to the vertex of this BrushMesh.HalfEdge . See Also BrushMesh"
  },
  "api/RealtimeCSG.Foundation.CSGNodeType.html": {
    "href": "api/RealtimeCSG.Foundation.CSGNodeType.html",
    "title": "Enum CSGNodeType | RealtimeCSG",
    "keywords": "Enum CSGNodeType Enum which describes the type of a node Syntax public enum CSGNodeType : byte Remarks note This enum is mirrored on the native side and cannot be modified. Branch Node is a CSGTreeBranch . Brush Node is a CSGTreeBrush . None Invalid or unknown node. Tree Node is a CSGTree ."
  },
  "api/RealtimeCSG.Foundation.CSGTreeBrushFlags.html": {
    "href": "api/RealtimeCSG.Foundation.CSGTreeBrushFlags.html",
    "title": "Enum CSGTreeBrushFlags | RealtimeCSG",
    "keywords": "Enum CSGTreeBrushFlags Flags to modify default brush behavior. Syntax [Serializable] [Flags] public enum CSGTreeBrushFlags Remarks note This enum is mirrored on the native side and cannot be modified. Default This brush has no special states Infinite When set the brush is infinitely large. This can be used, for instance, to create an inverted world, by putting everything inside an infinitely large brush."
  },
  "api/RealtimeCSG.Foundation.SurfaceFlags.html": {
    "href": "api/RealtimeCSG.Foundation.SurfaceFlags.html",
    "title": "Enum SurfaceFlags | RealtimeCSG",
    "keywords": "Enum SurfaceFlags Flags that define how surfaces in a BrushMesh behave. Syntax [Serializable] [Flags] public enum SurfaceFlags Remarks note This enum is mirrored on the native side and cannot be modified. None The surface has no flags set TextureIsInWorldSpace When set, the surface texture coordinates are calculated in world-space instead of brush-space"
  },
  "api/RealtimeCSG.Legacy.HalfEdge.html": {
    "href": "api/RealtimeCSG.Legacy.HalfEdge.html",
    "title": "Struct HalfEdge | RealtimeCSG",
    "keywords": "Struct HalfEdge A HalfEdge of a ControlMesh . Syntax [Serializable] public struct HalfEdge Remarks note This code will be replaced by pure BrushMesh code eventually. note This class can be safely serialized. Constructors HalfEdge(Int16, Int32, Int16, Boolean) Creates a HalfEdge for a ControlMesh Declaration public HalfEdge(short polygonIndex, int twinIndex, short vertexIndex, bool hardEdge = true) Parameters Int16 polygonIndex The index to the Polygon in the ControlMesh this HalfEdge belongs to. Int32 twinIndex The index to the twin edge HalfEdge in the ControlMesh this HalfEdge belongs to. Int16 vertexIndex The index to a vertex in the ControlMesh this HalfEdge belongs to. Boolean hardEdge Fields HardEdge Declaration public bool HardEdge Field Value Boolean Is this edge considered an internal or external (hard) edge PolygonIndex Declaration public short PolygonIndex Field Value Int16 Index to the Polygon in the ControlMesh this HalfEdge belongs to. TwinIndex Declaration public int TwinIndex Field Value Int32 Index to the twin edge HalfEdge in the ControlMesh this HalfEdge belongs to. VertexIndex Declaration public short VertexIndex Field Value Int16 Index to a vertex in the ControlMesh this HalfEdge belongs to. See Also ControlMesh Polygon Shape"
  },
  "api/RealtimeCSG.Foundation.CSGManager.html": {
    "href": "api/RealtimeCSG.Foundation.CSGManager.html",
    "title": "Class CSGManager | RealtimeCSG",
    "keywords": "Class CSGManager This class is manager class for all CSGTreeNode s. Inheritance Object CSGManager Syntax public sealed class CSGManager Properties AllBrushMeshInstances Declaration public static BrushMeshInstance[] AllBrushMeshInstances { get; } Property Value BrushMeshInstance [] All the BrushMeshInstance s. AllTreeNodes Declaration public static CSGTreeNode[] AllTreeNodes { get; } Property Value CSGTreeNode [] All the CSGTreeNode s. AllTrees Declaration public static CSGTree[] AllTrees { get; } Property Value CSGTree [] All the CSGTree s. BrushMeshCount Declaration public static int BrushMeshCount { get; } Property Value Int32 The number of BrushMesh es. TreeBranchCount Declaration public static int TreeBranchCount { get; } Property Value Int32 The number of CSGTreeBranch es. TreeBrushCount Declaration public static int TreeBrushCount { get; } Property Value Int32 The number of CSGTreeBrush es. TreeCount Declaration public static int TreeCount { get; } Property Value Int32 The number of CSGTree s. TreeNodeCount Declaration public static int TreeNodeCount { get; } Property Value Int32 The number of CSGTreeNode s. VersionName Declaration public static string VersionName { get; } Property Value String Methods Clear() Destroys all CSGTreeNode s and all BrushMesh es. Declaration public static void Clear() ClearDirty(CSGTreeNode) Declaration public static bool ClearDirty(CSGTreeNode node) Parameters CSGTreeNode node Returns Boolean Destroy(CSGTreeNode[]) Destroy all CSGTreeNode s contained in nodes . Declaration public static bool Destroy(CSGTreeNode[] nodes) Parameters CSGTreeNode [] nodes The CSGTreeNode s to destroy Returns Boolean True on success, false if there was a problem with destroying the CSGTreeNode s. See the log for more information. Exceptions ArgumentNullException Thrown when the nodes is null. Flush() Updates all pending changes to all CSGTree s. Declaration public static bool Flush() Returns Boolean True if any CSGTree s have been updated, false if no changes have been found. Rebuild() Clears all caches and rebuilds all CSGTree s. Declaration public static void Rebuild()"
  },
  "api/RealtimeCSG.Foundation.CSGTreeBrush.html": {
    "href": "api/RealtimeCSG.Foundation.CSGTreeBrush.html",
    "title": "Struct CSGTreeBrush | RealtimeCSG",
    "keywords": "Struct CSGTreeBrush A leaf node in a CSG tree that has a shape (a BrushMesh ) with which CSG operations can be performed. Syntax public struct CSGTreeBrush Remarks note This struct is a reference to node that exists on the native side, therefore its internal ID is not persistent. note This struct can be converted into a CSGTreeNode and back again. note Be careful when keeping track of CSGTreeBrush s because BrushMeshID s can be recycled after being Destroyed. See the CSG Trees and Brush Meshes articles for more information. Properties Bounds Declaration public Bounds Bounds { get; } Property Value Bounds Gets the bounds of this CSGTreeBrush . BrushMesh Declaration public BrushMeshInstance BrushMesh { get; set; } Property Value BrushMeshInstance Sets or gets a BrushMeshInstance Remarks By modifying the BrushMeshInstance you can change the shape of the CSGTreeBrush note BrushMeshInstance s can be shared between CSGTreeBrush es. See Also BrushMesh Dirty Declaration public bool Dirty { get; } Property Value Boolean Returns the dirty flag of the CSGTreeBrush . When the it's dirty, then it means (some of) its generated meshes have been modified. Flags Declaration public CSGTreeBrushFlags Flags { get; set; } Property Value CSGTreeBrushFlags Gets or sets CSGTreeBrush specific flags. LocalTransformation Declaration public Matrix4x4 LocalTransformation { get; set; } Property Value Matrix4x4 Gets or sets the transformation of the brush relative to the tree root. NodeID Declaration public int NodeID { get; } Property Value Int32 Gets the NodeID of the CSGTreeBrush , which is a unique ID of this node. Remarks note NodeIDs are eventually recycled, so be careful holding on to Nodes that have been destroyed. Operation Declaration public CSGOperationType Operation { get; set; } Property Value CSGOperationType The CSG operation that this CSGTreeBrush will use. Parent Declaration public CSGTreeBranch Parent { get; } Property Value CSGTreeBranch Returns the parent CSGTreeBranch this CSGTreeBrush is a child of. Returns an invalid node if it's not a child of any CSGTreeBranch . Tree Declaration public CSGTree Tree { get; } Property Value CSGTree Returns tree this CSGTreeBrush belongs to. UserID Declaration public int UserID { get; } Property Value Int32 Gets the UserID set to the CSGTreeBrush at creation time. Valid Declaration public bool Valid { get; } Property Value Boolean Returns if the current CSGTreeBrush is valid or not. Remarks note If Valid is false that could mean that this node has been destroyed. Methods Create(Matrix4x4, BrushMeshInstance, CSGOperationType, CSGTreeBrushFlags) Generates a brush on the native side and returns a CSGTreeBrush struct that contains a reference to it. Declaration public static CSGTreeBrush Create(Matrix4x4 localTransformation, BrushMeshInstance brushMesh = default (BrushMeshInstance), CSGOperationType operation = CSGOperationType.Additive, CSGTreeBrushFlags flags = CSGTreeBrushFlags.Default) Parameters Matrix4x4 localTransformation The transformation of the brush relative to the tree root BrushMeshInstance brushMesh A BrushMeshInstance , which is a reference to a BrushMesh . CSGOperationType operation The CSGOperationType that needs to be performed with this CSGTreeBrush . CSGTreeBrushFlags flags CSGTreeBrush specific flags Returns CSGTreeBrush A new CSGTreeBrush . May be an invalid node if it failed to create it. Create(Int32, Matrix4x4, BrushMeshInstance, CSGOperationType, CSGTreeBrushFlags) Generates a brush on the native side and returns a CSGTreeBrush struct that contains a reference to it. Declaration public static CSGTreeBrush Create(int userID, Matrix4x4 localTransformation, BrushMeshInstance brushMesh = default (BrushMeshInstance), CSGOperationType operation = CSGOperationType.Additive, CSGTreeBrushFlags flags = CSGTreeBrushFlags.Default) Parameters Int32 userID A unique id to help identify this particular brush. For instance, this could be an InstanceID to a UnityEngine.Object Matrix4x4 localTransformation The transformation of the brush relative to the tree root BrushMeshInstance brushMesh A BrushMeshInstance , which is a reference to a BrushMesh . CSGOperationType operation The CSGOperationType that needs to be performed with this CSGTreeBrush . CSGTreeBrushFlags flags CSGTreeBrush specific flags Returns CSGTreeBrush A new CSGTreeBrush . May be an invalid node if it failed to create it. Create(Int32, BrushMeshInstance, CSGOperationType, CSGTreeBrushFlags) Generates a brush on the native side and returns a CSGTreeBrush struct that contains a reference to it. Declaration public static CSGTreeBrush Create(int userID = 0, BrushMeshInstance brushMesh = default (BrushMeshInstance), CSGOperationType operation = CSGOperationType.Additive, CSGTreeBrushFlags flags = CSGTreeBrushFlags.Default) Parameters Int32 userID A unique id to help identify this particular brush. For instance, this could be an InstanceID to a UnityEngine.Object BrushMeshInstance brushMesh A BrushMeshInstance , which is a reference to a BrushMesh . CSGOperationType operation The CSGOperationType that needs to be performed with this CSGTreeBrush . CSGTreeBrushFlags flags CSGTreeBrush specific flags Returns CSGTreeBrush A new CSGTreeBrush . May be an invalid node if it failed to create it. Destroy() Destroy this CSGTreeBrush . Sets the state to invalid. Declaration public bool Destroy() Returns Boolean true on success, false on failure SetDirty() Force set the dirty flag of the CSGTreeBrush . Declaration public void SetDirty() See Also CSGTreeNode CSGTree CSGTreeBranch BrushMesh BrushMeshInstance"
  },
  "api/RealtimeCSG.Foundation.SurfaceDescription.html": {
    "href": "api/RealtimeCSG.Foundation.SurfaceDescription.html",
    "title": "Struct SurfaceDescription | RealtimeCSG",
    "keywords": "Struct SurfaceDescription Describes how the texture coordinates and normals are generated and if a surface is, for example, Renderable and/or Collidable etc. Syntax [Serializable] public struct SurfaceDescription Remarks note This struct is mirrored on the native side and cannot be modified. Fields smoothingGroup Declaration public uint smoothingGroup Field Value UInt32 The current normal smoothing group, 0 means that the surface doesn't do any smoothing Remarks note This is only used when normals are set to be generated using the VertexChannelFlags . surfaceFlags Declaration public SurfaceFlags surfaceFlags Field Value SurfaceFlags Surface specific flags UV0 Declaration public UVMatrix UV0 Field Value UVMatrix 2x4 matrix to calculate UV0 coordinates from vertex positions. Remarks note This is only used when uv0 channels are set to be generated using the VertexChannelFlags . See Also BrushMesh.Polygon BrushMesh"
  },
  "api/RealtimeCSG.Legacy.ControlMesh.html": {
    "href": "api/RealtimeCSG.Legacy.ControlMesh.html",
    "title": "Class ControlMesh | RealtimeCSG",
    "keywords": "Class ControlMesh Defines the shape of a convex brush that can be used in CSG operations. Inheritance Object ControlMesh Syntax [Serializable] public sealed class ControlMesh Remarks note This code will be replaced by pure BrushMesh code eventually. note This class can be safely serialized. Constructors ControlMesh() Create an uninitialized ControlMesh Declaration public ControlMesh() ControlMesh(ControlMesh) Create new ControlMesh by copying an existing ControlMesh . Declaration public ControlMesh(ControlMesh other) Parameters ControlMesh other The ControlMesh to copy from. Fields Edges Declaration public HalfEdge[] Edges Field Value HalfEdge [] HalfEdge s that are used by this ControlMesh Generation Declaration public int Generation Field Value Int32 Every time this ControlMesh changes, this value can be increased to easily detect modifications over time. Polygons Declaration public Polygon[] Polygons Field Value Polygon [] Polygon s that are used by this ControlMesh Vertices Declaration public Vector3[] Vertices Field Value Vector3 [] Vertices that are used by this ControlMesh Properties Valid Declaration public bool Valid { get; set; } Property Value Boolean true if valid, false if not. Methods Clone() Return a copy of this ControlMesh . Declaration public ControlMesh Clone() Returns ControlMesh The copy of this ControlMesh . CopyFrom(ControlMesh) Copy the contents of another ControlMesh to this ControlMesh . Declaration public void CopyFrom(ControlMesh other) Parameters ControlMesh other The ControlMesh to copy from. GetEdgePolygonIndex(Int32) Get the index to the polygon of the given HalfEdge that is found using halfEdgeIndex Declaration public short GetEdgePolygonIndex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex Index to a HalfEdge Returns Int16 A index to a Polygon in this ControlMesh GetNextEdgeIndex(Int32) Get the next index to a HalfEdge of the Polygon associated with the HalfEdge found with the given halfEdgeIndex Declaration public int GetNextEdgeIndex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex Index to a HalfEdge Returns Int32 A index to a HalfEdge in this ControlMesh GetNextEdgeIndexAroundVertex(Int32) Get the next index to a HalfEdge around the vertex associated with the HalfEdge found with the given halfEdgeIndex Declaration public int GetNextEdgeIndexAroundVertex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex Index to a HalfEdge Returns Int32 A index to a HalfEdge in this ControlMesh GetPrevEdgeIndex(Int32) Get the previous index to a HalfEdge of the Polygon associated with the HalfEdge found with the given halfEdgeIndex Declaration public int GetPrevEdgeIndex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex Index to a HalfEdge Returns Int32 A index to a HalfEdge in this ControlMesh GetTwinEdgeIndex(ref HalfEdge) Get the index to twin HalfEdge of the given HalfEdge Declaration public int GetTwinEdgeIndex(ref HalfEdge halfEdge) Parameters HalfEdge halfEdge The HalfEdge to get a vertex for Returns Int32 A index to a HalfEdge in this ControlMesh GetTwinEdgeIndex(Int32) Get the index to twin HalfEdge of the given HalfEdge that is found using halfEdgeIndex Declaration public int GetTwinEdgeIndex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex Index to a HalfEdge Returns Int32 A index to a HalfEdge in this ControlMesh GetTwinEdgePolygonIndex(Int32) Get the index to the polygon of the twin HalfEdge of the given HalfEdge that is found using halfEdgeIndex Declaration public short GetTwinEdgePolygonIndex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex Index to a HalfEdge Returns Int16 A index to a Polygon in this ControlMesh GetTwinEdgeVertex(ref HalfEdge) Get the vertex of the twin of the given HalfEdge Declaration public Vector3 GetTwinEdgeVertex(ref HalfEdge halfEdge) Parameters HalfEdge halfEdge The HalfEdge to get a vertex for Returns Vector3 A vertex in this ControlMesh GetTwinEdgeVertex(Int32) Get the vertex of the twin of the given HalfEdge that is found using halfEdgeIndex Declaration public Vector3 GetTwinEdgeVertex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex Index to a HalfEdge Returns Vector3 A vertex in this ControlMesh GetTwinEdgeVertexIndex(ref HalfEdge) Get the index to the vertex of the twin of the given HalfEdge Declaration public short GetTwinEdgeVertexIndex(ref HalfEdge halfEdge) Parameters HalfEdge halfEdge The HalfEdge to get a vertex for Returns Int16 A index to a vertex in this ControlMesh GetTwinEdgeVertexIndex(Int32) Get the index to the vertex of the twin of the given HalfEdge that is found using halfEdgeIndex Declaration public short GetTwinEdgeVertexIndex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex Index to a HalfEdge Returns Int16 A index to a vertex in this ControlMesh GetVertex(ref HalfEdge) Get the vertex that is associated with the given HalfEdge Declaration public Vector3 GetVertex(ref HalfEdge halfEdge) Parameters HalfEdge halfEdge The HalfEdge to get a vertex for Returns Vector3 A vertex GetVertex(Int32) For an index to a HalfEdge , return the vertex associated with it. Declaration public Vector3 GetVertex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex The index to the HalfEdge Returns Vector3 A vertex that belongs to a HalfEdge . If the halfEdgeIndex was invalid it returns a zero vertex. GetVertexIndex(ref HalfEdge) Get the vertex index that is associated with the given HalfEdge Declaration public short GetVertexIndex(ref HalfEdge halfEdge) Parameters HalfEdge halfEdge The HalfEdge to get a vertex for Returns Int16 A index to a vertex in this ControlMesh GetVertexIndex(Int32) Get the vertex index that is associated with the given HalfEdge that is found using halfEdgeIndex Declaration public short GetVertexIndex(int halfEdgeIndex) Parameters Int32 halfEdgeIndex Index to a HalfEdge Returns Int16 A index to a vertex in this ControlMesh GetVertices(Int32[]) Returns the vertices for the given array of indices to HalfEdge s. Declaration public Vector3[] GetVertices(int[] halfEdgeIndices) Parameters Int32 [] halfEdgeIndices Indices to HalfEdge s. Returns Vector3 [] An array of vertices Reset() Clear the contents of this ControlMesh . Declaration public void Reset() SetDirty() Increase the Generation of this ControlMesh so that we can detect that its been changed. Declaration public void SetDirty() See Also Polygon HalfEdge TexGen TexGenFlags Shape"
  },
  "api/RealtimeCSG.Legacy.TextureMatrixSpace.html": {
    "href": "api/RealtimeCSG.Legacy.TextureMatrixSpace.html",
    "title": "Enum TextureMatrixSpace | RealtimeCSG",
    "keywords": "Enum TextureMatrixSpace Specifies if a matrix, used to calculate uv coordinates with, is in plane or world space Syntax public enum TextureMatrixSpace Remarks note This code is legacy and will be removed eventually. PlaneSpace Texture matrix is in plane space WorldSpace Texture matrix is in world space"
  },
  "api/RealtimeCSG.Foundation.BrushMesh.Polygon.html": {
    "href": "api/RealtimeCSG.Foundation.BrushMesh.Polygon.html",
    "title": "Struct BrushMesh.Polygon | RealtimeCSG",
    "keywords": "Struct BrushMesh.Polygon Defines the polygon of a BrushMesh . Syntax [Serializable] public struct Polygon Remarks note This struct is mirrored on the native side and cannot be modified. Fields edgeCount Declaration public int edgeCount Field Value Int32 The number or edges of this BrushMesh.Polygon . firstEdge Declaration public int firstEdge Field Value Int32 The index to the first half edge that forms this BrushMesh.Polygon . layers Declaration public SurfaceLayers layers Field Value SurfaceLayers Describes the surface layers that this BrushMesh.Polygon is part of, and, for example, what Materials it uses. See Also MeshQuery polygonID Declaration public int polygonID Field Value Int32 An ID that can be used to identify the BrushMesh.Polygon . surface Declaration public SurfaceDescription surface Field Value SurfaceDescription Describes how normals and texture coordinates are created. See Also BrushMesh"
  },
  "api/RealtimeCSG.Foundation.CSGOperationType.html": {
    "href": "api/RealtimeCSG.Foundation.CSGOperationType.html",
    "title": "Enum CSGOperationType | RealtimeCSG",
    "keywords": "Enum CSGOperationType Defines how the CSG operation is performed on the intersection between CSGTreeBrush es and/or CSGTreeBranch es. Syntax [Serializable] public enum CSGOperationType : byte Remarks See the CSG Trees article for more information. note This enum is mirrored on the native side and cannot be modified. Additive The given CSGTreeBrush or CSGTreeBranch is added to the CSGTree and removes all the geometry inside it. Intersecting The given CSGTreeBrush or CSGTreeBranch removes all the geometry that is outside it. Subtractive The given CSGTreeBrush or CSGTreeBranch removes all the geometry that are inside it."
  },
  "api/RealtimeCSG.Foundation.LayerUsageFlags.html": {
    "href": "api/RealtimeCSG.Foundation.LayerUsageFlags.html",
    "title": "Enum LayerUsageFlags | RealtimeCSG",
    "keywords": "Enum LayerUsageFlags Define which layers of BrushMesh.Polygon s of BrushMesh es that should be combined to create meshes. Syntax [Serializable] [Flags] public enum LayerUsageFlags Remarks note The CSG process has no concept of, for instance, Renderable or Collidable flags and just compares the bits set on the layerUsage of the BrushMesh.Polygon s with the bits set in the MeshQuery . note Only bits 0-23 can be used for layers, the 24th bit is used to find Culled polygons. CastShadows Find the polygons that: cast shadows Collidable Find the polygons that: are part of a collider Culled Find polygons that have been removed by the CSG process, this can be used for debugging. None No layers, can be used to find BrushMesh.Polygon s that are not assigned to any layers. ReceiveShadows Find the polygons that: receive shadows Renderable Find the polygons that: are visible RenderCastShadows Find the polygons that: are visible and cast shadows. RenderReceiveCastShadows Find the polygons that: are visible, cast shadows and receive shadows. RenderReceiveShadows Find the polygons that: are visible and receive shadows."
  },
  "api/RealtimeCSG.Legacy.BrushFactory.html": {
    "href": "api/RealtimeCSG.Legacy.BrushFactory.html",
    "title": "Class BrushFactory | RealtimeCSG",
    "keywords": "Class BrushFactory Legacy factory class to create ControlMesh es and Shape s with Inheritance Object BrushFactory Syntax public sealed class BrushFactory Remarks note This class is legacy and will be replaced by a BrushMesh based version eventually. Methods CreateCube(UnityEngine.Vector3, UnityEngine.Material) Creates a cube BrushMesh with size and optional material Declaration public static BrushMesh CreateCube(UnityEngine.Vector3 size, UnityEngine.Material material = null) Parameters UnityEngine.Vector3 size The size of the cube UnityEngine.Material material The UnityEngine.Material that will be set to all surfaces of the cube (optional) Returns BrushMesh A BrushMesh on success, null on failure CreateSurfaceDescription(Surface, TexGen, TexGenFlags) Converts a Surface / TexGen / TexGenFlags combination into a SurfaceDescription . Declaration public static SurfaceDescription CreateSurfaceDescription(Surface surface, TexGen texGen, TexGenFlags texGenFlags) Parameters Surface surface A legacy Surface that describes how the texture space is orientated relative to the brush. TexGen texGen A legacy TexGen that describes how the texture coordinates are calculated in the SurfaceDescription . TexGenFlags texGenFlags A legacy TexGenFlags enum that describes if the SurfaceDescription texture generation will be in world-space or brush-space. Returns SurfaceDescription A new SurfaceDescription CreateSurfaceLayer(TexGen, TexGenFlags) Converts a TexGen / TexGenFlags pair into a SurfaceLayers . Declaration public static SurfaceLayers CreateSurfaceLayer(TexGen texGen, TexGenFlags texGenFlags) Parameters TexGen texGen A legacy TexGen that describes what layer parameters will be used for this surface. TexGenFlags texGenFlags A legacy TexGenFlags that describes what layers will be used for this surface Returns SurfaceLayers A new SurfaceLayers"
  },
  "api/RealtimeCSG.Legacy.TexGenFlags.html": {
    "href": "api/RealtimeCSG.Legacy.TexGenFlags.html",
    "title": "Enum TexGenFlags | RealtimeCSG",
    "keywords": "Enum TexGenFlags Flags to specify in what meshes a surface is part of Syntax [Flags] public enum TexGenFlags Remarks note This code is legacy and will be removed eventually. NoCastShadows Surface does not cast shadows. NoCollision Surface is not part of the collision mesh. None Surface uses default settings NoReceiveShadows Surface does not receive shadows. NoRender Surface is not rendered. WorldSpaceTexture UV coordinates are calculated in brush space instead of world space."
  },
  "api/RealtimeCSG.Foundation.CSGTree.html": {
    "href": "api/RealtimeCSG.Foundation.CSGTree.html",
    "title": "Struct CSGTree | RealtimeCSG",
    "keywords": "Struct CSGTree The root of a CSG tree which is used to generate meshes with. All other types of nodes are children of this node. Syntax public struct CSGTree Remarks note This struct is a reference to node that exists on the native side, therefore its internal ID is not persistent. note This struct can be converted into a CSGTreeNode and back again. note Be careful when keeping track of CSGTree s because BrushMeshID s can be recycled after being Destroyed. See the CSG Trees and Create Unity Meshes documentation for more information. Properties Count Declaration public int Count { get; } Property Value Int32 Gets the number of elements contained in the CSGTree . Dirty Declaration public bool Dirty { get; } Property Value Boolean Returns the dirty flag of the CSGTree . When the it's dirty, then it means (some of) its generated meshes have been modified. Item[Int32] Gets child at the specified index. Declaration public CSGTreeNode this[int index] { get; } Parameters Int32 index The zero-based index of the child to get. Property Value CSGTreeNode The element at the specified index. NodeID Declaration public int NodeID { get; } Property Value Int32 Gets the NodeID of the CSGTree , which is a unique ID of this node. Remarks note NodeIDs are eventually recycled, so be careful holding on to Nodes that have been destroyed. UserID Declaration public int UserID { get; } Property Value Int32 Gets the UserID set to the CSGTree at creation time. Valid Declaration public bool Valid { get; } Property Value Boolean Returns if the current CSGTree is valid or not. Remarks note If Valid is false that could mean that this node has been destroyed. Methods Add(CSGTreeNode) Adds a CSGTreeNode to the end of the CSGTree . Declaration public bool Add(CSGTreeNode item) Parameters CSGTreeNode item The CSGTreeNode to be added to the end of the CSGTree . Returns Boolean true on success, false on failure AddRange(CSGTreeNode[]) Adds the CSGTreeNode s of the specified array to the end of the CSGTree . Declaration public bool AddRange(params CSGTreeNode[] array) Parameters CSGTreeNode [] array The array whose CSGTreeNode s should be added to the end of the CSGTree . The array itself cannot be null. Returns Boolean true on success, false on failure ChildrenToArray() Copies the CSGTreeNode s of the CSGTree to a new array. Declaration public CSGTreeNode[] ChildrenToArray() Returns CSGTreeNode [] An array containing the CSGTreeNode s of the CSGTree . Clear() Removes all children from the CSGTree . Declaration public void Clear() Contains(CSGTreeNode) Determines whether the CSGTree contains a specific value. Declaration public bool Contains(CSGTreeNode item) Parameters CSGTreeNode item The Object to locate in the CSGTree . Returns Boolean true if item is found in the CSGTree ; otherwise, false . CopyChildrenTo(CSGTreeNode[], Int32) Copies the immediate children of the CSGTree to an Array, starting at a particular Array index. Declaration public int CopyChildrenTo(CSGTreeNode[] array, int arrayIndex) Parameters CSGTreeNode [] array The one-dimensional Array that is the destination of the elements copied from CSGTree . The Array must have zero-based indexing. Int32 arrayIndex The zero-based index in array at which copying begins. Returns Int32 The number of children copied into array . Create(CSGTreeNode[]) Generates a tree on the native side and returns a CSGTree struct that contains a reference to it. Declaration public static CSGTree Create(params CSGTreeNode[] children) Parameters CSGTreeNode [] children The child nodes that are children of this tree. A tree may not have duplicate children, contain itself or contain a CSGTree . Returns CSGTree A new CSGTree . May be an invalid node if it failed to create it. Create(Int32, CSGTreeNode[]) Generates a tree on the native side and returns a CSGTree struct that contains a reference to it. Declaration public static CSGTree Create(int userID, params CSGTreeNode[] children) Parameters Int32 userID A unique id to help identify this particular tree. For instance, this could be an InstanceID to a UnityEngine.Object . CSGTreeNode [] children The child nodes that are children of this tree. A tree may not have duplicate children, contain itself or contain a CSGTree . Returns CSGTree A new CSGTree . May be an invalid node if it failed to create it. Destroy() Destroy this CSGTreeNode . Sets the state to invalid. Declaration public bool Destroy() Returns Boolean true on success, false on failure GetGeneratedMesh(GeneratedMeshDescription) Creates and returns a GeneratedMeshContents for a given GeneratedMeshDescription created by GetMeshDescriptions(MeshQuery[], VertexChannelFlags) Declaration public GeneratedMeshContents GetGeneratedMesh(GeneratedMeshDescription meshDescription) Parameters GeneratedMeshDescription meshDescription A GeneratedMeshDescription created by GetMeshDescriptions(MeshQuery[], VertexChannelFlags) . Returns GeneratedMeshContents A GeneratedMeshContents that can be used to initialize a UnityEngine.Mesh with. Remarks See the Create Unity Meshes article for more information. See Also GetMeshDescriptions(MeshQuery[], VertexChannelFlags) GetMeshDescriptions(MeshQuery[], VertexChannelFlags) Determines what meshes would be generated from the tree from the given meshQuery and vertexChannelMask . Declaration public GeneratedMeshDescription[] GetMeshDescriptions(MeshQuery[] meshQuery, VertexChannelFlags vertexChannelMask = VertexChannelFlags.Tangent | VertexChannelFlags.Normal | VertexChannelFlags.UV0 | VertexChannelFlags.All) Parameters MeshQuery [] meshQuery An array of MeshQuery 's which describe which surfaces should be combined into meshes VertexChannelFlags vertexChannelMask A mask to prevent certain vertex channels to be generated. By default this value is to All . Returns GeneratedMeshDescription [] An array of GeneratedMeshDescription 's that can be used to generate GeneratedMeshContents using GetGeneratedMesh(GeneratedMeshDescription) Remarks See the Create Unity Meshes article for more information. See Also GetGeneratedMesh(GeneratedMeshDescription) IndexOf(CSGTreeNode) Determines the index of a specific child in the CSGTree . Declaration public int IndexOf(CSGTreeNode item) Parameters CSGTreeNode item The CSGTreeNode to locate in the CSGTree . Returns Int32 The index of item if found in the CSGTree ; otherwise, –1. Insert(Int32, CSGTreeNode) Inserts an element into the CSGTreeNode at the specified index. Declaration public bool Insert(int index, CSGTreeNode item) Parameters Int32 index The zero-based index at which item should be inserted. CSGTreeNode item The CSGTreeNode to insert. Returns Boolean true on success, false on failure InsertRange(Int32, CSGTreeNode[]) Inserts the CSGTreeNode s of an array into the CSGTreeNode at the specified index. Declaration public bool InsertRange(int index, params CSGTreeNode[] array) Parameters Int32 index The zero-based index at which the new CSGTreeNode s should be inserted. CSGTreeNode [] array The array whose CSGTreeNode s should be inserted into the CSGTreeNode . The array itself cannot be null. Returns Boolean true on success, false on failure Remove(CSGTreeNode) Removes a specific CSGTreeNode from the CSGTree . Declaration public bool Remove(CSGTreeNode item) Parameters CSGTreeNode item The CSGTreeNode to remove from the CSGTree . Returns Boolean true on success, false on failure RemoveAt(Int32) Removes the child at the specified index of the CSGTree . Declaration public bool RemoveAt(int index) Parameters Int32 index The zero-based index of the child to remove. Returns Boolean true on success, false on failure RemoveRange(Int32, Int32) Removes a range of children from the CSGTree . Declaration public bool RemoveRange(int index, int count) Parameters Int32 index The zero-based starting index of the range of children to remove. Int32 count The number of children to remove. Returns Boolean true on success, false on failure SetDirty() Force set the dirty flag of the CSGTreeNode . Declaration public void SetDirty() See Also CSGTreeNode CSGTreeBranch CSGTreeBrush"
  }
}